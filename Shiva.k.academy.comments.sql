----1. SQL QUERY TO WRITE CUMMULATIVE SUM OF SALARY.
SELECT employee_id, first_name, department_id, salary, SUM(salary) over() FROM hr.employees; -- IT GIVES SUM OF SALARY OF ALL EMPLOYEES.
---OR
SELECT E.*, SUM(salary) over() FROM hr.employees E;

--IT GIVES CUMMULATIVE SUM OF SALARY OF ALL EMPLOYEES (24000, 24000+15000=39000, 39000+14000=53000 etc.)
SELECT employee_id, first_name, department_id, salary, SUM(salary) over(ORDER BY employee_id ) FROM hr.employees;

--IT GIVES CUMMULATIVE SUM OF SALARY OF ALL EMPLOYEES FOR EACH DEPARTMENT.
--DEPT_ID-10 SALARY IS 4400, DEPT_ID-20 13000+6000=19000 etc.
SELECT employee_id, first_name, department_id, salary, SUM(salary) over(PARTITION BY department_id ORDER BY employee_id ) CUM_SUM_DEPT 
FROM hr.employees
ORDER BY employee_id;
---over(PARTITION BY department_id ORDER BY employee_id ) IF WE USE ORDER BY SALARY IT CUMMULATES ACCORDING TO SALARY.



--- FIND THE BANK CUMMULATIVE TRANSACTION.
CREATE TABLE BANKTRANS
(
TN_NO NUMBER(10),
TN_DATE DATE,
ACC_NUMBER NUMBER(38),
AMOUNT NUMBER(10),
TN_TYPE VARCHAR2(5)
);



INSERT ALL
INTO BANKTRANS VALUES(6,'01-FEB-19',22222255555444,100,'D')
INTO BANKTRANS VALUES(7,'02-FEB-19',22222255555444,20,'C')
INTO BANKTRANS VALUES(8,'03-FEB-19',22222255555444,10,'D')
INTO BANKTRANS VALUES(9,'04-FEB-19',22222255555444,30,'C')
INTO BANKTRANS VALUES(10,'05-FEB-19',22222255555444,20,'C')
INTO BANKTRANS VALUES(1,'01-FEB-19',1111255555333,1000,'D')
INTO BANKTRANS VALUES(2,'02-FEB-19',1111255555333,300,'C')
INTO BANKTRANS VALUES(3,'03-FEB-19',1111255555333,100,'C')
INTO BANKTRANS VALUES(4,'04-FEB-19',1111255555333,400,'C')
INTO BANKTRANS VALUES(5,'05-FEB-19',1111255555333,200,'C')
SELECT * FROM DUAL;

UPDATE BANKTRANS
SET TN_TYPE = 'D'
WHERE TN_NO= 3;

SELECT * FROM BANKTRANS;

SELECT TN_NO, TN_DATE, ACC_NUMBER, AMOUNT, TN_TYPE,
SUM(DECODE(TN_TYPE,'D',AMOUNT,'C',AMOUNT*-1)) OVER(PARTITION BY ACC_NUMBER ORDER BY TN_DATE) CUM_TRNS
FROM BANKTRANS;



----2. "COLUMN LEVEL CONSTRAINTS" VS "TABLE LEVEL CONSTRAINTS".

--"COLUMN LEVEL CONSTRAINTS" HERE CONSTRAINTS LIKE UNIQUE,PRIMARY KEY etc. ARE DEFINED IN COLUMNS ITSELF.
--HERE WE CAN DEFINE CONSTRAINTS TO ONLY ONE COLUMN, WE CANNOT DEFINE TO MULTIPLE COLUMNS.
CREATE TABLE STUD_CONSTRAINTS
(
REG_NO NUMBER UNIQUE,
ROLL_NO NUMBER,
DEPT VARCHAR2(10),
NAME VARCHAR2(10)
);

--"TABLE LEVEL CONSTRAINTS" HERE CONSTRAINTS LIKE UNIQUE,PRIMARY KEY etc. ARE DEFINED AS PART OF A TABLE.
--HERE WE CAN DEFINE CONSTRAINTS OT MULTIPLE COLUMNS.
CREATE TABLE STUD_CONSTRAINTS1
(
REG_NO NUMBER,
ROLL_NO NUMBER,
DEPT VARCHAR2(10),
NAME VARCHAR2(10),
CONSTRAINTS U1 UNIQUE(REG_NO,DEPT)
);


----3.WHAT IS THE USE OF "SELECT 1" IN CORRELATED SUBQUERY.
--THE PURPOSE OF "SELECT 1" IS JUST SELECT ANY COLUMN AS PART OF SYNTAX BEFORE FROM KEYWORD.
--INSTED OF "SELECT 1" WE CAN USE ANYTHING IN THE PLACE OF "1" LIKE "SELECT *", "SELECT NULL", "SELECT 1,2,3" AND "SELECT #)
SELECT * FROM departments dept
WHERE NOT EXISTS ( SELECT 1
                    FROM employees emp WHERE dept.department_id=emp.DEPARTMENT_ID);
                    
                    
----4.WHY WE USE "INLINE VIEWS".
-- USED TO EASE THE SELECT STATEMENT.
--INSTED OF CREATING TABLE AND USE FOR EVERY THING, WE CREATE VIRTUAL TABLE BY USING "INLINE VIEW".
SELECT (SELECT dept.department_name 
        FROM departments dept
        WHERE  dept.department_Id=emp.department_id) dept_name,
         ROUND(AVG(salary)) avg_sal
FROM employees emp
GROUP BY emp.department_id;  ---HERE IT INCLUDE NULL VALUE ALSO.



---WE GET SAME RESULT BUT IT EXCLUDE NULL VALUE.
select dept.department_name,Round(avg(salary)) from employees emp, departments dept
where dept.department_Id=emp.department_id
group by dept.department_name ;

----5. WRITE SQL TO MASK FIRST 12 DIGITS OF GIVEN INPUT NUMBER OF 16 DIGITS.

STEP:1
SELECT '1111222233334444' d FROM DUAL;

STEP:2
WITH DATA AS(
            SELECT '1111222233334444' d FROM DUAL)
SELECT * 
FROM DATA;

STEP:3
WITH DATA AS(
            SELECT '1111222233334444' d FROM DUAL)
SELECT SUBSTR(d,1,LENGTH(d)-4),
        SUBSTR(d,-4)
FROM DATA;

STEP:4
WITH DATA AS(
            SELECT '1111222233334444' d FROM DUAL)
SELECT LPAD('X',LENGTH(d)-4,'X'),
        SUBSTR(d,-4)
FROM DATA;

STEP:4
WITH DATA AS(
            SELECT '1111222233334444' d FROM DUAL)
SELECT LPAD('X',LENGTH(d)-4,'X')||   ---CONCAINATE
        SUBSTR(d,-4) ACCOUNT_NO
FROM DATA; ---HERE SUBSTR(d,-4) WORKS FOR ONLY FIXED LENGTH OF STRINGS  LIKE HERE 16.


---FOR VARIYING LENGTH OF STRINGS 
WITH DATA AS(
            SELECT '1111222233334444' d FROM DUAL)
SELECT LPAD('X',LENGTH(d)-4,'X')||   ---CONCAINATE
        SUBSTR(d, CASE WHEN LENGTH(d)<=4 THEN 1 ELSE -4 END) ACCOUNT_NO
FROM DATA;
---OR

WITH DATA AS(
            SELECT '1111222233334444' d FROM DUAL)
SELECT REGEXP_REPLACE(SUBSTR(d,1,LENGTH(d)-4),'[^.]','X')||   ---IN REGEXPRESSION '[^.}' MEANS REPLACE ANY LETTER EXPECT "." OR '[^@]' MEANS REPLACE ANY OTHER LETTERS EXPECT '@'.
        SUBSTR(d, CASE WHEN LENGTH(d)<=4 THEN 1 ELSE -4 END) ACCOUNT_NO
FROM DATA;



----6. WRITE SQL TO UPDATE "1" TO "0" AND "0" TO "1" IN GIVEN INPUT TABLE.
CREATE TABLE REPLACE0TO1
(
C1 NUMBER);

INSERT ALL
INTO REPLACE0TO1 VALUES(1)
INTO REPLACE0TO1 VALUES(1)
INTO REPLACE0TO1 VALUES(0)
INTO REPLACE0TO1 VALUES(1)
INTO REPLACE0TO1 VALUES(0)
INTO REPLACE0TO1 VALUES(0)
INTO REPLACE0TO1 VALUES(1)
INTO REPLACE0TO1 VALUES(1)
SELECT * FROM DUAL;

SELECT * FROM REPLACE0TO1;

UPDATE REPLACE0TO1
SET C1 = DECODE(C1,1,0,0,1);

ROLLBACK;

--OR

UPDATE REPLACE0TO1
SET C1=(CASE WHEN C1=0 THEN 1 ELSE 0 END);
--OR

UPDATE REPLACE0TO1
SET C1= (CASE C1 WHEN 0 THEN 1 
                    WHEN 1 THEN 0 END);

UPDATE REPLACE0TO1
SET C1=(CASE WHEN C1=0 THEN 1 ELSE 0 END);

--OR
ROLLBACK;

UPDATE REPLACE0TO1
SET C1= 1-C1;

----7.CAN FORIGN KEY REFERS TO PRIMARY KEY IN SAME TABLE.
--CONSIDE TABLE HR.EMPLOYEES WHERE "EMPLOYEE _ID" IS ALSO REFERED TO "MANAGER_ID" HERE "EMPLOYEE _ID" IS PRIMARY KEY AND "MANAGER_ID" IS FORIGN KEY WHICH IS IN A SAME TABLE.
-- EXAMPLE TABLE IS BELOW.

CREATE TABLE EMPLOY
(
EMP_ID NUMBER PRIMARY KEY,
EMP_NAME VARCHAR2(25),
MGR_ID NUMBER REFERENCES EMPLOY(EMP_ID)
);

----8.WRITE SQL TO SELECT ALTERNATE RECORDS(EVEN/ODD) FROM TABLE.

--TO DISPLAY ONLY EVEN NUMBER EMPLOYEE_ID.
SELECT * FROM(
                SELECT ROWNUM R,
                employee_id,first_name,manager_id 
                FROM employees)
WHERE MOD(R,2)=1;

--TO DISPLAY ONLY ODD NUMBER EMPLOYEE_ID.
SELECT * FROM(
SELECT ROWNUM R,
employee_id,first_name,manager_id 
FROM employees)
WHERE MOD(R,2)=0;

----9. WRITE A SQL TO GET THE EXPECTED OUTPUT AS ONLY ONE RECORD FROM SOURCE AND DESTINATION BECAUSE FAIR IS SAME FOR THE GIVEN INPUT TABLE.

CREATE TABLE ROUTE
(
SOURCE1 VARCHAR2(10),
DESTINATION VARCHAR2(10),
TAVEL_FAIR NUMBER
);

INSERT ALL
INTO ROUTE VALUES('CHN','BNG',500)
INTO ROUTE VALUES('BNG','CHN',500)
INTO ROUTE VALUES('HYD','MUMB',2000)
INTO ROUTE VALUES('MUMB','HYD',2000)
INTO ROUTE VALUES('PUNE','UP',5000)
SELECT * FROM DUAL;


SELECT * FROM ROUTE;


SELECT DISTINCT LEAST(SOURCE1, DESTINATION),
        GREATEST(SOURCE1, DESTINATION),
TAVEL_FAIR
FROM ROUTE;

----10. a).FOR OVERALL SALARY.
SELECT EMPLOYEE_ID,FIRST_NAME,SUM(SALARY) OVER() TOTAL_SALARY FROM employees;

---B). FOR DEPARTWISE SUM OF SALARY.
SELECT EMPLOYEE_ID,FIRST_NAME,DEPARTMENT_ID,SALARY,SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) DEPT_TOTAL_SAL FROM employees;


----11. RANK AND DENSE_RANK AS "AGGREGATE" AND "ANALYTICAL" FUNCTION.
---RANK IS 1,1,3,4,5,5,7,8,9,10.
--DENSE_RANK 1,1,2,3,4,4,5,6,7,7,7,8,9,10.

--AGGREGATE FUNCTION IS DEFINED AS IT TAKES MULTIPLE ROW OF OUTPUT DO THE AGGREGATION AND GIVES SINGLE VALUE.
--AGGREGATE FUNCTIONS AVG,SUM,MAX,MIN,RANK,DENSE_RANK etc.
--FINDING 12000 SALARY RANK IN EMPLOYEES TABLE.
SELECT RANK(12000) WITHIN GROUP (ORDER BY SALARY DESC),
        DENSE_RANK(12000) WITHIN GROUP (ORDER BY SALARY DESC)
FROM EMPLOYEES;

---ANALYTICAL FUNCTION IS DEFINED AS IT TAKES MULTIPLE ROW OF OUTPUT DO THE AGGREGATION AND GIVES MULTIPLE ROW OUTPUT. 
---USING ANALYTICAL FUNCTION RANK AND DENSE_RANK EMPLOYEES TABLE.
SELECT EMPLOYEE_ID,FIRST_NAME,DEPARTMENT_ID,RANK() OVER(ORDER BY SALARY DESC),
        DENSE_RANK() OVER(ORDER BY SALARY DESC)
FROM EMPLOYEES;

---USING ANALYTICAL FUNCTION RANK AND DENSE_RANK BY DEPARTMENTWISE.
SELECT EMPLOYEE_ID,FIRST_NAME,DEPARTMENT_ID,RANK() OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) RANK1,
        DENSE_RANK() OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) DENSE_RANK1
FROM EMPLOYEES;


----12.WRITE SQL TO FIND "SIMILAR" NAMES IN THE GIVEN TABLE.
CREATE TABLE EMP_DETAIL
(
EMPNO NUMBER,
EMP_NAME VARCHAR2(20)
);

INSERT ALL
INTO EMP_DETAIL VALUES(1,'ravi')
INTO EMP_DETAIL VALUES(2,'(RAVI)')
INTO EMP_DETAIL VALUES(3,'SCOTT')
INTO EMP_DETAIL VALUES(4,'(**RAVI**)')
INTO EMP_DETAIL VALUES(5,'King')
INTO EMP_DETAIL VALUES(6,'SMITH')
INTO EMP_DETAIL VALUES(7,'smith')
INTO EMP_DETAIL VALUES(8,'(smitH)')
INTO EMP_DETAIL VALUES(9,'RAVI')
INTO EMP_DETAIL VALUES(10,'Smith????')
SELECT * FROM DUAL;

SELECT * FROM EMP_DETAIL;

STEP:1
SELECT EMPNO, EMP_NAME,
        REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]')
FROM EMP_DETAIL;

STEP:2
SELECT COUNT(*),
        LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))
FROM EMP_DETAIL
GROUP BY LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))
HAVING COUNT(*) >1;

STEP:3
SELECT  LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))
FROM EMP_DETAIL
GROUP BY LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))
HAVING COUNT(*) >1;

STEP:4
SELECT * FROM EMP_DETAIL
WHERE LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]')) IN(
SELECT  LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))
FROM EMP_DETAIL
GROUP BY LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))
HAVING COUNT(*) >1)
ORDER BY EMPNO;

--OR
SELECT EMPNO, EMP_NAME,C FROM (
SELECT 
        EMPNO, 
        EMP_NAME,
        COUNT(*) OVER(PARTITION BY LOWER(REGEXP_REPLACE(EMP_NAME,'[^A-Za-z]'))) C
FROM EMP_DETAIL)
WHERE C>1
ORDER BY EMPNO ;


----13.a).WRITE SQL QUERY TO FIND DUPLICATE ROUTE FROM TABLE BELOW.
---b). WRITE A DELETE STATEMENT TO REMOVE DUPLICATE ROUTES.

CREATE TABLE DUPLICATEROUTE
(
CITY1 VARCHAR2(20),
CITY2 VARCHAR2(20),
FARE NUMBER(10)
);

INSERT ALL
INTO DUPLICATEROUTE VALUES('BANGLORE','CHENNAI',2000)
INTO DUPLICATEROUTE VALUES('CHENNAI','BANGLORE',2000)
INTO DUPLICATEROUTE VALUES('BANGLORE','PUNE',4000)
INTO DUPLICATEROUTE VALUES('KOLKATA','BANGLORE',6000)
INTO DUPLICATEROUTE VALUES('BANGLORE','KOLKATA',6000)
SELECT * FROM DUAL;

SELECT * FROM DUPLICATEROUTE;

---a).WRITE SQL QUERY TO FIND DUPLICATE ROUTE FROM TABLE BELOW.
SELECT GREATEST( CITY1, CITY2) CITY1,LEAST( CITY1, CITY2) CITY2,FARE,COUNT(*)
FROM DUPLICATEROUTE
GROUP BY GREATEST( CITY1, CITY2),LEAST( CITY1, CITY2),FARE
HAVING COUNT(*) >1;

---b). WRITE A DELETE STATEMENT TO REMOVE DUPLICATE ROUTES.
DELETE FROM DUPLICATEROUTE WHERE ROWID NOT IN(
SELECT  MAX(ROWID)
FROM DUPLICATEROUTE
GROUP BY GREATEST( CITY1, CITY2),LEAST( CITY1, CITY2),FARE);

SELECT * FROM DUPLICATEROUTE;


----14. WHAT IS THE USE OF WITH CLAUSE.
---WITH CLUASE HELPS US TO COMPUTE SOME RESULT SETS,THIS RESULT SET IS USED IN MULTIPLE PLACES IN THE QUERY.
---USING "WITH" CLAUSE, WE CAN GIVE A NAME FOR A SUBQUERY, AND CAN REFER THE NAME IN SEVERAL PLACES IN THE MAIN SQL.
--- THE WITH CLAUSE CAN BE ACCESSED IN THE MAIN SQL, AS IF IT WAS A TABLE, HENCE THIS WILL ACT LIKE A TEMPORARY RESULT STORAGE, COMPUTED ONCE AND CAN BE REUSED IN MULTIPLE PLACES.
--- USING WITH CLAUSE WE CAN EVEN IMPLEMENT RECURSIVE QUERIES(COMMON TABLE EXPRESSION).
WITH T AS (
            SELECT 'WELLCOME' D 
            FROM DUAL)
    SELECT SUBSTR(D,LEVEL) R1,
           SUBSTR(D,1,LEVEL) R2,
           SUBSTR(D,LEVEL,1) R3,
           SUBSTR(D,-LEVEL) R4,
           SUBSTR(D,-LEVEL,1) R5
    FROM T
    CONNECT BY LEVEL <= LENGTH(D);

----15. TRIGGER ON DELETE VS TRUNCATE.
---IF WE TRY TO DELETE TABLE ORACLE WILL THROUG ERROR MESSAGE LIKE " raise_application_error(-20001,'Deletion not allowed'".
---BUT IF WE TRUNCATE THE TABLE IT WILL REMOVE ALL RECORDS BECAUSE WE OR NOT DEFINED "DDL" COMMAND.
--- IF WE CREATE TRUNCATE TRIGGER WE CAN NOT DELETE OR TRUNCATE TABLE.
---DML TRIGGER DEFINED ON TABLE OBJECTS.
---DDL TRIGGER DEFINED ON SCHEMA OR ON DATABASE.

SELECT * FROM BSEIT1;

---CRETAE DELETE TRIGGER.(DML TRIGGER).
CREATE OR REPLACE TRIGGER bseit1_del_trig 
BEFORE DELETE ON chethan
FOR EACH ROW
BEGIN
if ora_dict_obj_name = 'bseit1' and ora_dict_obj_type = 'TABLE' then 
        raise_application_error(-20001,'Deletion not allowed');
end if;
END;
/

DELETE TABLE BSEIT1;
ROLLBACK;


---CREATE TRUNCATE TRIGGER.(DDL TRIGGER).
CREATE OR REPLACE TRIGGER bseit1_truncate_trig
        BEFORE TRUNCATE ON SCHEMA
BEGIN
        rise application_error(-20001,'TRUNCATION NOT ALLOWED ON TABLES');
        END;
        /
TRUNCATE TABLE BSEIT1;



--- HOW TO DROP TRIGGER.
DROP TRIGGER bseit1_truncate_trig;

DROP TRIGGER bseit1_del_trig;




----16. FIND SIZE OF THE TABLE. 

SELECT SEGMENT_NAME, BYTES/1024/1024 AS MB FROM USER_SEGMENTS 
WHERE segment_name='BSEIT1';

----OR

SELECT 
        owner,
        table_name,
        sum(bytes) / 1024 / 1024 AS total_table_size_mb
FROM 
    (
        SELECT 
                segment_type,
                segment_name table_name,
                owner,
                bytes
            FROM
                dba_segments
            WHERE
                 segment_name = 'BSEIT1'
                 )
GROUP BY table_name,owner;







----17. HOW TO GET UNIQUE RECORDS WITHOUT USING "DISTINCT" IN ORACLE.
CREATE TABLE DUPLICATERECORDS
(
ROLL_NO NUMBER,
STU_NAMES VARCHAR2(20)
);


INSERT ALL
INTO DUPLICATERECORDS VALUES(1,'KING')
INTO DUPLICATERECORDS VALUES(1,'KING')
INTO DUPLICATERECORDS VALUES(2,'KIRAN')
INTO DUPLICATERECORDS VALUES(3,'PAVAN')
INTO DUPLICATERECORDS VALUES(4,'RAMU')
INTO DUPLICATERECORDS VALUES(4,'RAMU')
INTO DUPLICATERECORDS VALUES(5,'SOMU')
INTO DUPLICATERECORDS VALUES(6,'BHIMA')
INTO DUPLICATERECORDS VALUES(7,'ROHAN')
INTO DUPLICATERECORDS VALUES(8,'RAMESH')
SELECT * FROM DUAL;

SELECT * FROM DUPLICATERECORDS;

SELECT DISTINCT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
GROUP BY ROLL_NO,STU_NAMES
ORDER BY ROLL_NO;

--OR

SELECT UNIQUE ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
GROUP BY ROLL_NO,STU_NAMES
ORDER BY ROLL_NO;

--OR

SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
GROUP BY ROLL_NO,STU_NAMES
ORDER BY ROLL_NO;

--OR
SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
UNION
SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS;

--OR

SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
INTERSECT
SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS;

--OR

SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
UNION
SELECT NULL,NULL
FROM DUAL WHERE 1=2;

--OR

SELECT ROLL_NO,STU_NAMES
FROM DUPLICATERECORDS
MINUS
SELECT NULL,NULL
FROM DUAL;

--OR
SELECT * FROM (
                SELECT ROLL_NO, STU_NAMES, ROW_NUMBER() OVER(PARTITION BY ROLL_NO, STU_NAMES ORDER BY ROLL_NO, STU_NAMES) R
                FROM DUPLICATERECORDS)
WHERE R = 1;

--OR
SELECT * FROM (
                SELECT ROLL_NO, STU_NAMES, RANK() OVER(PARTITION BY ROLL_NO, STU_NAMES ORDER BY ROWNUM) R
                FROM DUPLICATERECORDS)
WHERE R = 1;


----18.SIMILARITIES AND DIFFERENCES OF "DECODE" AND "CASE".
CREATE TABLE DECODECASE
(
S_NO NUMBER,
S_NAME VARCHAR2(20),
S_MARK NUMBER,
S_RESULT VARCHAR2(1)
);

INSERT ALL 
INTO DECODECASE VALUES(1,'SCOTT',85,'P')
INTO DECODECASE VALUES(2,'ALLEN',30,'F')
INTO DECODECASE VALUES(3,'SMITH',45,'P')
INTO DECODECASE VALUES(4,'ADAMS',25,'F')
INTO DECODECASE VALUES(5,'JAMES',55,NULL)
SELECT * FROM DUAL;

SELECT * FROM DECODECASE;

---USING "DECODE".
SELECT S_NO, S_NAME, S_MARK, 
        DECODE(S_RESULT,'P','PASS','F','FAIL','RESULT NOT AVAILABLE') AS RESULT
FROM DECODECASE;
--DECODE ONLY DO EQUALITY FUNCTION ONLY.

SELECT 
        DECODE (:INPUT,'1','ONE','2','TWO','3','THREE','NONE') OUTPUT
        FROM DUAL;


---USING "CASE".
SELECT S_NO, S_NAME, S_MARK, 
        CASE S_RESULT
                    WHEN 'P' THEN 'PASS'
                    WHEN 'F' THEN 'FAIL'
                    ELSE 'RESULT NOT AVAILABLE'
                    END
                    AS RESULT
FROM DECODECASE;

--OR
SELECT S_NO, S_NAME, S_MARK, 
             CASE 
                    WHEN S_RESULT = 'P' THEN 'PASS'--WE CAN DO ANY TYPE OF LOGICAL IMPLEMENTATION HERE(=,>,<,<=,>=, OR, AND , ANY, NOT)
                    WHEN S_RESULT = 'F' THEN 'FAIL'
                    ELSE 'RESULT NOT AVAILABLE'
                    END
                    AS RESULT
FROM DECODECASE;

--OR

SELECT S_NO, S_NAME, S_MARK, 
             CASE 
                    WHEN S_RESULT = 'P' AND S_MARK >= 60 THEN 'PASS - FIRST CLASS'--WE CAN DO ANY TYPE OF LOGICAL IMPLEMENTATION HERE(=,>,<,<=,>=, OR, AND , ANY, NOT)
                    WHEN S_RESULT = 'P' AND S_MARK <60  THEN 'PASS - SECOND CLASS'
                    WHEN S_RESULT = 'F' THEN 'FAIL'
                    ELSE 'RESULT NOT AVAILABLE'
                    END
                    AS RESULT
FROM DECODECASE;

SELECT 
        CASE :INPUT
        WHEN '1' THEN 'ONE'  --- IN "CASE" STATEMENT NUMBER AND STRING SHOULD BE IN SINGLE QUOTES.
        WHEN '2' THEN 'TWO'
        WHEN '3' THEN 'THREE'
        ELSE 'NONE' 
        END  
        AS  RESULT
FROM DUAL;

----19.DIFFERENCE BETWEEN REPLACE AND TRANSLATE.
---IN REPLACE IT REPLACES ENTIRE WORD.
---IN TRANSLATE IT REPLACES ONLY CHARACTERS.
SELECT REPLACE('welcome to oracle class','oracle','python') FROM DUAL;---HERE REPLACES ORACLE WITH PYTHON.

SELECT REPLACE('welcome to oracle class','oracle','') FROM DUAL;---HERE IT REMOVES ORACLE WORD BECAUSE WE ARE NOT SPECIFY ANY WORD TO REPLACE.


SELECT TRANSLATE('welcome to oracle class','abcde','12345') FROM DUAL;--HERE REPLACES 'a' by '1' , 'b' by '2', 'c' by '3', '4' by 'd' and '5' by 'e'.

SELECT TRANSLATE('welcome to oracle class','abcde','1234') FROM DUAL;---HERE SAME AS ABOVE EXAMPLE BUT "e" IS REMOVED BECAUSE THERE IS NO CHARACTER TO REPLACE "e".

SELECT TRANSLATE('welcome to oracle class','abcde','123') FROM DUAL;--- HERE "d" AND "e" ARE REMOVED BECAUSE THERE IS NO REPLACEMENT CHARACTER PRESENT.



----20.WHAT IS "VIEW" IN ORACLE?, WHAT IS SIMPLAE AND COMPLEX VIEW?.
---VIEW IS A LOGICAL TABLE BASED ON OTHER UNDERLYING TABLES OR VIEW.
---"VIEW" DOESNOT HOLD ANY DATA OF IT'S OWN, IT RETRIEVES THE DATA FROM BASE TABLE / VIEW WHENEVER THE VIEW IS QUIRED FOR.
---VIEWS ARE USED TO PRESENT THE SAME DATA IN MULTIPLE FORMATS (SAY,AGREGATED,DETAILED etc.).
---VIEW METADATA ONLY OBJECT (OR WE CAN SAY NAMED QUIRES).
--- IT DOESNOT CONSUME ANY SPACE IN DATABASE BECAUSE IT DOES NOT HOLD ANY DATA.
---WE CAN CREATE VIEW AND GRANT PERMISSION TO OTHER USER BY HIDING SENSITIVE OR UNWANTED DATA.


CREATE VIEW EMP
AS SELECT * FROM EMPLOYEES 
WHERE DEPARTMENT_ID=10;

SELECT * FROM EMP;

CREATE OR REPLACE VIEW EMP1
AS SELECT * FROM EMPLOYEES 
WHERE DEPARTMENT_ID=50;---IF TABLE PRESENT, TO REPLACE WE USE "CREATE OR REPLACE VIEW".

CREATE OR REPLACE VIEW EMP_SAL
AS SELECT DEPARTMENT_ID,MAX(SALARY) "MAX_SAL", TRUNC(AVG(SALARY)) "AVG_SAL",MIN(SALARY) "MIN_SAL"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

SELECT * FROM EMP_SAL;

SELECT * FROM USER_VIEWS;---IT SHOWS ALL THE CREATED VIEW INFORMATIONS.

SELECT * FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'EMP_SAL'; --- IT GIVES ALL COLUMNS DETAILS OF VIEW CREATED.

DROP VIEW EMP1;

SELECT * FROM EMP1;


----21. NULL AND ARITHMETIC OPERATIONS.
CREATE TABLE NULLTABLE
(
C NUMBER);

INSERT ALL
INTO NULLTABLE VALUES(1)
INTO NULLTABLE VALUES(2)
INTO NULLTABLE VALUES(null)
INTO NULLTABLE VALUES(4)
INTO NULLTABLE VALUES(null)
INTO NULLTABLE VALUES(5)
SELECT * FROM DUAL;

SELECT * FROM NULLTABLE;

---"null" NOT GIVE RESULT IF WE USE "=","<>"  etc LOGICAL OPERATORS
SELECT * FROM  NULLTABLE WHERE C= null;---IT WILL NOT GIVE ANY RESULT.

SELECT * FROM  NULLTABLE WHERE C<> null;---IT WILL NOT GIVE ANY RESULT.

---"null" GIVE RESULT IF WE USE "IS", "IS NOT" OPERATORS.
SELECT * FROM  NULLTABLE WHERE C is  null;

SELECT * FROM  NULLTABLE WHERE C is NOT null;

SELECT * FROM  NULLTABLE WHERE C <= 1 OR C is null;

SELECT COUNT(*) FROM NULLTABLE;

SELECT COUNT(*), COUNT(C) FROM NULLTABLE; ---COUNT(*) COUNT ALL RECORDS INCLUDING "NULL" ALSO BUT GROUP RECORDS COUNT(C) COUNT ONLY NOT NULL VALUES.

SELECT COUNT(*), COUNT(C),AVG(C) FROM NULLTABLE;---"AVG" CONSIDER ONLY NOT NULL VALUES.
--OR
SELECT COUNT(*), COUNT(C),SUM(C)/COUNT(C) FROM NULLTABLE;

SELECT 1+NULL FROM DUAL; ---ANY "ARITHMETIC OPERATION" WITH "NULL" IS "NULL" ONLY.

SELECT * FROM NULLTABLE ORDER BY C;---BY DEFAULT NULL WILL BE AT LAST.
---OR 
SELECT * FROM NULLTABLE ORDER BY C ASC;---NULL WILL BE AT LAST
---OR
SELECT * FROM NULLTABLE ORDER BY C NULLS LAST;--- WE SPECIFIED AS NULLS LAST.


SELECT * FROM NULLTABLE ORDER BY C NULLS FIRST;--- NULL WILL BE AT FIRST AS WE SPECIFIED.

SELECT * FROM NULLTABLE ORDER BY C  DESC NULLS FIRST;---NULL WILL BE AT FIRST AND OTHERS ARE ARRANGED ACCORDING TO DESC.

SELECT * FROM NULLTABLE ORDER BY C  DESC NULLS LAST;---NULL WILL BE AT LAST AND OTHERS ARE ARRANGED ACCORDING TO DESC.



-----22. "IN" AND "ANY" OPERATOR.
CREATE TABLE INANY
(
C NUMBER);

INSERT ALL
INTO INANY VALUES(10)
INTO INANY VALUES(20)
INTO INANY VALUES(30)
INTO INANY VALUES(40)
INTO INANY VALUES(50)
INTO INANY VALUES(60)
INTO INANY VALUES(70)
INTO INANY VALUES(80)
INTO INANY VALUES(90)
INTO INANY VALUES(100)
SELECT * FROM DUAL;

SELECT * FROM INANY;

--"IN" AND "ANY" OPERATORS.
SELECT * FROM INANY WHERE C IN (30,50,70);
--OR
SELECT * FROM INANY WHERE C =ANY (30,50,70);
--OR
SELECT * FROM INANY WHERE C=30 OR C=50 OR C=70;
--OR
SELECT * FROM INANY WHERE C=30
UNION ALL
SELECT * FROM INANY WHERE C=50
UNION ALL
SELECT * FROM INANY WHERE C=70;

---">ANY" OPERATOR.
SELECT * FROM INANY WHERE C >ANY (30,50,70);--- GIVES GRATER VALUES THAN 30(GRATER THAN "SMALLEST VALUE" HERE "30").
--OR
SELECT * FROM INANY WHERE C>30 OR C>50 OR C>70;
--
SELECT * FROM INANY WHERE C>ANY 30;
--OR
SELECT * FROM INANY WHERE C>ANY (30,40);
--OR
SELECT * FROM INANY WHERE C>ANY (30,40,50);
--OR
SELECT * FROM INANY WHERE C>ANY (30,40,50,60);


----"<ANY" OPERATOR.
SELECT * FROM INANY WHERE C <ANY (30,50,70);--- GIVES SMALLER VALUES THAN 70(SMALLER  THAN "GRATEST VALUE" HERE "70").
--OR
SELECT * FROM INANY WHERE C<30 OR C<0 OR C<70;


----23. SQL TO DELETE DUPLICATE RECORDS.
CREATE TABLE DUPLICATEREC
(
EMPNO NUMBER,
ENAME VARCHAR2(20),
JOBNAME VARCHAR2(20),
SAL NUMBER,
DEPTNO NUMBER
);


INSERT ALL
INTO DUPLICATEREC VALUES(1001,'KING','PRESIDENT',100000,10)
INTO DUPLICATEREC VALUES(1002,'RAGHU','MANAGER',80000,20)
INTO DUPLICATEREC VALUES(1002,'RAGHU','MANAGER',80000,20)
INTO DUPLICATEREC VALUES(1003,'FORD','MANAGER',75000,10)
INTO DUPLICATEREC VALUES(1004,'JAMES','MANAGER',82000,30)
INTO DUPLICATEREC VALUES(1004,'JAMES','MANAGER',82000,30)
INTO DUPLICATEREC VALUES(1004,'JAMES','MANAGER',82000,30)
INTO DUPLICATEREC VALUES(1005,'WARD','SALESMAN',50000,10)
INTO DUPLICATEREC VALUES(1006,'FORD','SALESMAN',40000,10)
INTO DUPLICATEREC VALUES(1007,'SMITH','SALESMAN',45000,10)
SELECT * FROM DUAL;

SELECT * FROM DUPLICATEREC;


----STEP:1
SELECT ROWID,EMPNO, ENAME, JOBNAME, SAL, DEPTNO
FROM DUPLICATEREC;

----STEP:2
SELECT MAX(ROWID),EMPNO, ENAME, JOBNAME, SAL, DEPTNO
FROM DUPLICATEREC
GROUP BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO;

----STEP:3
SELECT * FROM DUPLICATEREC 
WHERE ROWID NOT IN (
            SELECT MAX(ROWID)
                FROM DUPLICATEREC
                GROUP BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO);

----STEP:4
DELETE DUPLICATEREC
WHERE ROWID NOT IN(
            SELECT MAX(ROWID)
            FROM DUPLICATEREC
            GROUP BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO);

SELECT * FROM DUPLICATEREC;---DUPLICATE ROES ARE DELETED.

---OR

---STEP:1
SELECT * FROM DUPLICATEREC A
WHERE ROWID >(
                SELECT MIN(ROWID)
                FROM DUPLICATEREC B
                WHERE A.EMPNO=B.EMPNO
                AND A.ENAME=B.ENAME
                AND A.JOBNAME=B.JOBNAME
                AND A.SAL=B.SAL
                AND A.DEPTNO=B.DEPTNO);

---STEP:2
DELETE DUPLICATEREC A
WHERE ROWID >(
                SELECT MIN(ROWID)
                FROM DUPLICATEREC B
                WHERE A.EMPNO=B.EMPNO
                AND A.ENAME=B.ENAME
                AND A.JOBNAME=B.JOBNAME
                AND A.SAL=B.SAL
                AND A.DEPTNO=B.DEPTNO)

select * from table(dbms_xplan.display_cursor(sql_id=>'618f3thumkb3p', format=>'ALLSTATS LAST'));

                
 SELECT * FROM DUPLICATEREC;---DUPLICATE ROWS ARE DELETED.
 
---OR

DELETE DUPLICATEREC A
WHERE ROWID <(
                SELECT MAX(ROWID)
                FROM DUPLICATEREC B
                WHERE A.EMPNO=B.EMPNO
                AND A.ENAME=B.ENAME
                AND A.JOBNAME=B.JOBNAME
                AND A.SAL=B.SAL
                AND A.DEPTNO=B.DEPTNO);
SELECT * FROM DUPLICATEREC;---DUPLICATE ROES ARE DELETED.
 
 ---OR

---STEP:1
SELECT EMPNO, ENAME, JOBNAME, SAL, DEPTNO,ROWID R1,
                            ROW_NUMBER() OVER(PARTITION BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO ORDER BY ROWNUM) R
                            FROM DUPLICATEREC
                            ORDER BY EMPNO;
                            
 
---STEP:2
 SELECT R1 FROM (
                            SELECT EMPNO, ENAME, JOBNAME, SAL, DEPTNO,ROWID R1,
                            ROW_NUMBER() OVER(PARTITION BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO ORDER BY ROWNUM) R
                            FROM DUPLICATEREC
                            ORDER BY EMPNO)
            WHERE R=1;
            

---STEP:3
SELECT * FROM DUPLICATEREC WHERE ROWID NOT IN(
            SELECT R1 FROM (
                            SELECT EMPNO, ENAME, JOBNAME, SAL, DEPTNO,ROWID R1,
                            ROW_NUMBER() OVER(PARTITION BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO ORDER BY ROWNUM) R
                            FROM DUPLICATEREC
                            ORDER BY EMPNO)
            WHERE R=1);
            
            
---STEP:4
DELETE DUPLICATEREC WHERE ROWID NOT IN(
            SELECT R1 FROM (
                            SELECT EMPNO, ENAME, JOBNAME, SAL, DEPTNO,ROWID R1,
                            ROW_NUMBER() OVER(PARTITION BY EMPNO, ENAME, JOBNAME, SAL, DEPTNO ORDER BY ROWNUM) R
                            FROM DUPLICATEREC
                            ORDER BY EMPNO)
            WHERE R=1);
 SELECT * FROM DUPLICATEREC;---DUPLICATE ROES ARE DELETED.
 
---OR
---DONT USE THIS IF INTERVIWER ASKS THEN ONLY USE THIS METHOD.
CREATE TABLE DUPLICATEREC_1 AS
SELECT DISTINCT EMPNO,ENAME,JOBNAME, SAL, DEPTNO 
FROM DUPLICATEREC;

DROP TABLE DUPLICATEREC;

ALTER TABLE DUPLICATEREC_1 
RENAME TO  DUPLICATEREC;


----****24 I HAVE A TABLE WITH DUPLICATE ENTRIES IN PRODUCTION, I CANNOT DELETE EXISTING ROWS, HOWEVER I WANT TO PREVENT FURTHER DUPLICATE ROWS TO GET INSERTED HOW CAN I DO.

CREATE TABLE AVOIDDUPLICATE
(
EMPNO NUMBER,
ENAME VARCHAR2(20),
JOBNAME VARCHAR2(20),
SAL NUMBER,
DEPTNO NUMBER
);


INSERT ALL
INTO AVOIDDUPLICATE VALUES(1001,'KING','PRESIDENT',100000,10)
INTO AVOIDDUPLICATE VALUES(1002,'RAGHU','MANAGER',80000,20)
INTO AVOIDDUPLICATE VALUES(1003,'RAMU','MANAGER',80000,20)
INTO AVOIDDUPLICATE VALUES(1002,'FORD','MANAGER',75000,10)
INTO AVOIDDUPLICATE VALUES(1001,'JAMES','MANAGER',82000,30)
INTO AVOIDDUPLICATE VALUES(1004,'JAMES','MANAGER',82000,30)
SELECT * FROM DUAL;
 
SELECT * FROM AVOIDDUPLICATE;

---IT SHOWS ERROR LIKE "primary key violated" WE CANNOT APPLAY UNIQUE CONSTRAINT OR PRIMARY KEY CONSTRAINT TO EXISTING TABLE WHEN DUPLICATES ARE ALREADY PRESENT.
ALTER TABLE AVOIDDUPLICATE ADD CONSTRAINT EMPNO_PK_CONS PRIMARY KEY(EMPNO); 

---WE USE "DEFERRABLE NOVALIDATE" TO OVERCOME ABOVE PROBLEM.
ALTER TABLE AVOIDDUPLICATE ADD CONSTRAINT EMPNO_PK_CONS PRIMARY KEY(EMPNO) DEFERRABLE NOVALIDATE;

INSERT INTO AVOIDDUPLICATE VALUES(1002,'SATISH','MANAGER',75000,10);---SHOWS ERROR BECAUSE UNIQUE CONSTRAINS IS APPLIED WE CANNOT ADD DUPLICATE NOW.


----**25. WHILE EXECUTING THE INSERT STATEMENT "INSERT INTO EMP_TARGET SELECT * FROM EMP_SOURCE; I WANT ONLY THE "NON-DUPLICATE" RECORDS TO GET INSERTED, DUPLICATE RECORDS SHOULD GET EXCLUDED DURING INSERTION, HOW CAN I DO?.
CREATE TABLE EMP_TARGET
(
EMPNO NUMBER PRIMARY KEY,
ENAME VARCHAR2(20)
);

INSERT ALL
INTO EMP_TARGET VALUES(1,'RAGHU')
INTO EMP_TARGET VALUES(2,'SURYA')
INTO EMP_TARGET VALUES(3,'VINAY')
INTO EMP_TARGET VALUES(4,'KIRAN')
SELECT * FROM DUAL;

CREATE TABLE EMP_SOURCE
(
EMPNO NUMBER PRIMARY KEY,
ENAME VARCHAR2(20)
);

INSERT ALL
INTO EMP_SOURCE VALUES(1,'RAGHU')
INTO EMP_SOURCE VALUES(2,'SURYA')
INTO EMP_SOURCE VALUES(5,'RAVI')
INTO EMP_SOURCE VALUES(6,'RAJA')
SELECT * FROM DUAL;


SELECT * FROM EMP_SOURCE;

SELECT * FROM EMP_TARGET;

---DBMS ERRLOG TABLE.
---THIS PACKAGE PROVIDES A PROCEDURE THAT ENABLE YOU TO CREATE AN ERROR LOGGING TABLE SO THAT DML OPERATIONS CAN CONTINUE AFTER ENCOUNTERING ERRORS RATHER THAN ABORT AND ROLLBACK. THIS ENABLE YOU TO SAVE TIME AND SYSTEM RESOURCES.

BEGIN 
    DBMS_ERRLOG.CREATE_ERROR_LOG (DML_TABLE_NAME => 'EMP_TARGET');
END;
/

INSERT INTO EMP_TARGET SELECT * FROM EMP_SOURCE
    LOG ERRORS INTO ERR$_EMP_TARGET
    REJECT LIMIT UNLIMITED;
    
SELECT * FROM EMP_TARGET;---DUPLICATE ARE REMOVED.

SELECT * FROM ERR$_EMP_TARGET;---REMOVED DUPLICATE DATA ARE STORED/CAPTURED HERE. IT IS USEFULL TO CHECK DELETED RECORDS.

----OR
---IGNORE_ROW_ON_DUPKEY_INDEX.
----HERE IT IS NOT CAPTURE DELETED RECORDS  DETAILS IS THE MAIN DISADVANTAGE HERE.
INSERT /*+ IGNORE_ROW_ON_DUPKEY_INDEX(EMP_TARGET(EMPNO))*/
INTO EMP_TARGET SELECT * FROM EMP_SOURCE;
 

-----**26.HOW TO HANDLE THE EXCEPTION RAISED FROM "MERGE" STATEMENT.
CREATE TABLE EMP_TGT1
(
EMPNO NUMBER,
ENAME VARCHAR2(20),
SAL NUMBER
);

INSERT ALL
INTO EMP_TGT1 VALUES(1,'RAVI',1000)
INTO EMP_TGT1 VALUES(2,'RAGHU',2000)
INTO EMP_TGT1 VALUES(3,'PRIYA',3000)
INTO EMP_TGT1 VALUES(4,'KAVIN',4000)
SELECT * FROM DUAL;

SELECT * FROM EMP_TGT1;


CREATE TABLE EMP_SRC1
(
EMPNO NUMBER,
ENAME VARCHAR2(20),
SAL NUMBER
);

INSERT ALL
INTO EMP_SRC1 VALUES(1,'RAVI',1000)
INTO EMP_SRC1 VALUES(2,'RAGHU',2000)
INTO EMP_SRC1 VALUES(3,'PRIYA',3500)
INTO EMP_SRC1 VALUES(4,'KAVIN',4000)
INTO EMP_SRC1 VALUES(5,'SUMAN',5000)
SELECT * FROM DUAL;

SELECT * FROM EMP_SRC1;

UPDATE EMP_TGT1
SET SAL = (SELECT EMP_SRC1.SAL
            FROM EMP_SRC1
            WHERE EMP_SRC1.EMPNO = EMP_TGT1.EMPNO);


INSERT INTO EMP_TGT1
SELECT * 
FROM EMP_SRC1
WHERE EMPNO NOT IN (SELECT EMPNO FROM EMP_TGT1);

ROLLBACK;

---OR USING "MERGE".
MERGE INTO EMP_TGT1
USING EMP_SRC1
ON (EMP_TGT1.EMPNO=EMP_SRC1.EMPNO)
WHEN MATCHED THEN 
UPDATE SET SAL = EMP_SRC1.SAL
WHEN NOT MATCHED THEN
INSERT VALUES(EMP_SRC1.EMPNO,EMP_SRC1.ENAME,EMP_SRC1.SAL);


----27.HERE SAME AS 26TH PROBLEM BUT SOURCE HAS ANOTHER COLUMN "RESIGNED". WE NEED TO DELETE EMPLOYEE DETAILS WHO IS RESIGNED(RESIGNED IS SHOWN AS "Y"}.
CREATE TABLE EMP_TGT2
(
EMPNO NUMBER,
ENAME VARCHAR2(20),
SAL NUMBER
);


INSERT ALL
INTO EMP_TGT2 VALUES(1,'RAVI',1000)
INTO EMP_TGT2 VALUES(2,'RAGHU',2000)
INTO EMP_TGT2 VALUES(3,'PRIYA',3000)
INTO EMP_TGT2 VALUES(4,'KAVIN',4000)
SELECT * FROM DUAL;

SELECT * FROM EMP_TGT2;

CREATE TABLE EMP_SRC2
(
EMPNO NUMBER,
ENAME VARCHAR2(20),
SAL NUMBER,
RESIGNED VARCHAR2(10)
);

INSERT ALL
INTO EMP_SRC2 VALUES(1,'RAVI',1000,'Y')
INTO EMP_SRC2 VALUES(2,'RAGHU',2000,'')
INTO EMP_SRC2 VALUES(3,'PRIYA',3500,'')
INTO EMP_SRC2 VALUES(4,'KAVIN',4000,'')
INTO EMP_SRC2 VALUES(5,'SUMAN',5000,'')
SELECT * FROM DUAL;

SELECT * FROM EMP_SRC2;

MERGE INTO EMP_TGT2
USING EMP_SRC2
ON (EMP_TGT2.EMPNO=EMP_SRC2.EMPNO)
WHEN MATCHED THEN 
UPDATE SET EMP_TGT2.SAL = EMP_SRC2.SAL
DELETE WHERE EMP_SRC2.RESIGNED = 'Y'
WHEN NOT MATCHED THEN
INSERT VALUES(EMP_SRC2.EMPNO,EMP_SRC2.ENAME,EMP_SRC2.SAL);


----28. QUESTIONS ABOUT VIEW.
---a). IF WE ADD A NEW COLUMN TO THE BASE TABLE,WILL THAT COLUMN GET ADDED TO VIEW.
--- ORACLE GIVE THE COLUMNS ONLY THOSE PRESENT AT THE TIME OF VIEW CREATION. VIEW DOES NOT AUTOMETICALLY UPDATE IF WE CREATE NEW COLUMN IN TABLE(EVEN IF WE SPECIFY SELECT * FROM ALSO DOES NOT UPDATE VIEW).

---b).IF WE DROP AN EXISTING COLUMN FROM THE BASE TABLE WHAT WILL HAPPEN TO VIEW ?.
--- ONCE THE UNDERLYING OBJECT IS REMOVED, IT CAN BE ANY OBJECT, IF THE ORACLE DOES NOT ABLE TO FIND THE OBJECT IT WILL THROW THE ERROR.

---c). HOW TO CHECK THE LIST OF OBJECT USED IN A VIEW ?.
SELECT * FROM USER_DEPENDENCIES
WHERE NAME = ' EMP_SAL';

-----29.GET DIAGNOL DATA FROM INPUT TABLE.
CREATE TABLE DIAGONALDATA
(
C1 NUMBER,
C2 NUMBER,
C3 NUMBER
);

INSERT ALL
INTO DIAGONALDATA VALUES(10,20,30)
INTO DIAGONALDATA VALUES(40,50,60)
INTO DIAGONALDATA VALUES(70,80,80)
SELECT * FROM DUAL;

SELECT * FROM DIAGONALDATA;

SELECT ROWNUM, (DECODE(ROWNUM,1,C1,0)+
                DECODE(ROWNUM,2,C2,0)+
                DECODE(ROWNUM,3,C3,0)) C
FROM DIAGONALDATA;

---OR

SELECT ROWNUM, (DECODE(ROWNUM,1,C1,2,C2,3,C3)) C
FROM DIAGONALDATA;

---OR

SELECT ROWNUM,
                CASE 
                    WHEN ROWNUM = '1' THEN C1
                    WHEN ROWNUM = '2' THEN C2
                    WHEN ROWNUM = '3' THEN C3
                    ELSE NULL
                    END 
                    AS C
FROM DIAGONALDATA;


----30. VALUES FROM MULTIPLE ROWS INTO SINGLE ROW.
CREATE TABLE SINGLEROW
(
C1 VARCHAR2(10),
C2 VARCHAR2(10),
C3 VARCHAR2(10),
C4 VARCHAR2(10),
C5 VARCHAR2(10),
C6 VARCHAR2(10)
);

INSERT ALL
INTO SINGLEROW VALUES('A1','A2','A3','A4','A5','A6')
INTO SINGLEROW VALUES('B1','B2','B3','B4','B5','B6')
INTO SINGLEROW VALUES('C1','C2','C3','C4','C5','C6')
SELECT * FROM DUAL;

SELECT * FROM SINGLEROW;

---STEP:1

SELECT ROWNUM,DECODE(ROWNUM,1,C1) C1,
                 DECODE(ROWNUM,1,C2) C2,
                 DECODE(ROWNUM,2,C3) C3,
                 DECODE(ROWNUM,2,C4) C4,
                 DECODE(ROWNUM,3,C5) C5,
                 DECODE(ROWNUM,3,C6) C6
FROM SINGLEROW;


---STEP:2

SELECT MAX(DECODE(ROWNUM,1,C1)) C1,
                 MAX(DECODE(ROWNUM,1,C2)) C2,
                 MAX(DECODE(ROWNUM,2,C3)) C3,
                 MAX(DECODE(ROWNUM,2,C4)) C4,
                 MAX(DECODE(ROWNUM,3,C5)) C5,
                 MAX(DECODE(ROWNUM,3,C6)) C6
FROM SINGLEROW;

INSERT ALL
INTO SINGLEROW VALUES('D1','D2','D3','D4','D5','D6')
INTO SINGLEROW VALUES('E1','E2','E3','E4','E5','E6')
INTO SINGLEROW VALUES('F1','F2','F3','F4','F5','F6')
SELECT * FROM DUAL;

---STEP:1
SELECT ROWNUM,ROWNUM/3,DECODE(ROWNUM,1,C1,4,C1) C1,
                 DECODE(ROWNUM,1,C2,4,C2) C2,
                 DECODE(ROWNUM,2,C3,5,C3) C3,
                 DECODE(ROWNUM,2,C4,5,C4) C4,
                 DECODE(ROWNUM,3,C5,6,C5) C5,
                 DECODE(ROWNUM,3,C6,6,C6) C6
FROM SINGLEROW;

---STEP:1
SELECT ROWNUM, MOD(ROWNUM,3), DECODE(MOD(ROWNUM,3),1,C1) C1,
                 DECODE(MOD(ROWNUM,3),1,C2) C2,
                 DECODE(MOD(ROWNUM,3),2,C3) C3,
                 DECODE(MOD(ROWNUM,3),2,C4) C4,
                 DECODE(MOD(ROWNUM,3),0,C5) C5,
                 DECODE(MOD(ROWNUM,3),0,C6) C6
FROM SINGLEROW;


---STEP:2
SELECT  MAX(DECODE(MOD(ROWNUM,3),1,C1)) C1,
                 MAX(DECODE(MOD(ROWNUM,3),1,C2)) C2,
                 MAX(DECODE(MOD(ROWNUM,3),2,C3)) C3,
                 MAX(DECODE(MOD(ROWNUM,3),2,C4)) C4,
                 MAX(DECODE(MOD(ROWNUM,3),0,C5)) C5,
                MAX( DECODE(MOD(ROWNUM,3),0,C6)) C6
FROM SINGLEROW
GROUP BY CEIL(ROWNUM/3);


----31. ONCE THE TABLE IS CREATED BY DEFINING DATA TYPES, IF I WANT TO INCREASE DATA TYPE LENGTH OR CHANGE DATA TYPE WHAT WE CAN DO.
---WE CAN INCREASE DATA TYPE LENGTH BY MODIFY TABLE.
--- WE CANNOT DECREASE DATA TYPE LENGTH(column to be modified must be empty to decrease precision or scale) AND CHANGE DATA TYPE(column to be modified must be empty to change datatype).
---TO OVER COME THIS WE NEED TO CREATE BACK UP TABLE (HERE "CHETHAN_BKP).
--- TRUNCATE TABLE "CHETHAN".
---MODIFY DATA TYPE AND DATA TYPE LENGTH.
--- COPY DATA FROM BACK UP TABLE(CHETHAN_BKP) TO ORIGINAL TABLE (CHETHAN).

SELECT * FROM CHETHAN;

DESC CHETHAN;

CREATE TABLE CHETHAN_BKP AS SELECT * FROM CHETHAN;

SELECT * FROM CHETHAN_BKP;

TRUNCATE TABLE CHETHAN;

ALTER TABLE CHETHAN
MODIFY EMPSALARY NUMBER(10);

ALTER TABLE CHETHAN
MODIFY EMPGENDER VARCHAR2(10);

INSERT INTO CHETHAN (SELECT * FROM CHETHAN_BKP);

SELECT * FROM CHETHAN;



----32.GET THE LIST OF VALUES DVISIBLE BY 3 THAT ARE LESS THAN 100.
---ROWWISE DATA.
SELECT L FROM (                
                    SELECT LEVEL L
                    FROM DUAL
                    CONNECT BY LEVEL <=100)
WHERE MOD(L,3)=0;

---COLUMNWISE DATA
SELECT LISTAGG(L, ',') WITHIN GROUP (ORDER BY L ASC ) FROM (                
                    SELECT LEVEL L
                    FROM DUAL
                    CONNECT BY LEVEL  <=100)
WHERE MOD(L,3)=0;

---OR
SELECT LISTAGG((ROWNUM*3),',') WITHIN GROUP(ORDER BY (ROWNUM*3))
FROM DUAL
CONNECT BY LEVEL <=100/3;

----33.WRIET A QUERY TO FIND THE "CUSTOMER WISE LAST TWO RECHARGED AMOUNT".

CREATE TABLE recharge_detail (
    recharge_date     DATE,
    cust_name         VARCHAR2(100),
    recharge_amount   NUMBER
);

insert into recharge_detail values( to_date('01/01/2019','DD/MM/YYYY'), 'Ragu',100);
insert into recharge_detail values( to_date('01/02/2019','DD/MM/YYYY'), 'Ragu',150);
insert into recharge_detail values( to_date('01/03/2019','DD/MM/YYYY'), 'Ragu',120);
insert into recharge_detail values( to_date('01/04/2019','DD/MM/YYYY'), 'Ragu',170);

insert into recharge_detail values( to_date('01/01/2019','DD/MM/YYYY'), 'Ravi',299);
insert into recharge_detail values( to_date('01/02/2019','DD/MM/YYYY'), 'Ravi',399);
insert into recharge_detail values( to_date('01/03/2019','DD/MM/YYYY'), 'Ravi',150);
insert into recharge_detail values( to_date('01/04/2019','DD/MM/YYYY'), 'Ravi',199);

insert into recharge_detail values( to_date('01/01/2019','DD/MM/YYYY'), 'Siva',100);
insert into recharge_detail values( to_date('01/02/2019','DD/MM/YYYY'), 'Siva',200);
insert into recharge_detail values( to_date('01/03/2019','DD/MM/YYYY'), 'Siva',400);
insert into recharge_detail values( to_date('01/04/2019','DD/MM/YYYY'), 'Siva',200);

SELECT * FROM recharge_detail;
WITH DT AS (
SELECT * FROM(
                    SELECT RECHARGE_DATE, CUST_NAME, RECHARGE_AMOUNT, DENSE_RANK() OVER(PARTITION BY CUST_NAME ORDER BY RECHARGE_DATE DESC) RANK
                    FROM recharge_detail)
WHERE RANK <=2)
SELECT  CUST_NAME, MAX(CASE WHEN RANK = 1 THEN RECHARGE_AMOUNT ELSE 0 END) LAST_RECHARGE_AMOUNT, 
MAX(CASE WHEN RANK = 2 THEN RECHARGE_AMOUNT ELSE 0 END) LAST_2ND_RECHARGE_AMOUNT
FROM DT
GROUP BY CUST_NAME ;


----34. WRITE A QUERY TO ASSIGN "GRADE" BASED ON EMPLOYEE SALARY.
CREATE TABLE emp_t (
    empno     number,
    ename     varchar2(100),
 sal       number
);

insert into emp_t values (1,'KING',100);
insert into emp_t values (2,'BLAKE',500);
insert into emp_t values (3,'CLARK',1200);
insert into emp_t values (4,'JONES',2500);
insert into emp_t values (5,'SCOTT',3000);
insert into emp_t values (6,'FORD',700);
insert into emp_t values (7,'SMITH',1700);
insert into emp_t values (8,'ALLEN',2600);
insert into emp_t values (9,'WARD',400);
insert into emp_t values (10,'MARTIN',1500);

SELECT * FROM emp_t;

SELECT ET.*, (CASE WHEN SAL >= 100 AND SAL<=500  THEN 'D' 
                    WHEN SAL >500 AND SAL <=1000 THEN 'C'
                     WHEN SAL >1000 AND SAL <=2000 THEN 'B'
                     WHEN SAL >2000  THEN 'A'
                    ELSE '0' 
                    END) GRADE 
FROM emp_t ET
ORDER BY GRADE ;

----OR
SELECT empno, ename, sal,R.GRADE
FROM emp_t,
            (SELECT 0 mi,1000 mx,'A' GRADE FROM dual
            UNION
            SELECT 1001 mi,2000 mx,'B' GRADE FROM dual
            UNION
            SELECT 2001 mi,999999 mx,'C' GRADE FROM dual) R
WHERE sal >=mi AND sal <=mx
ORDER BY R.GRADE;

----OR THIS IS MATHEMATICAL OPERATION SOME TIME WE CANNOT GET EACT ANSWER.
SELECT ET.*, DECODE(CEIL(SAL/1000),1,'C',2,'B','A') GRADE
FROM emp_t ET
ORDER BY GRADE;


----35. WRITE A QUERY TO GET THE COMBINATION OF ALL THE GIVEN VALUES IN TABLE1 AND TABLE2.
CREATE TABLE INPUTTAB1
(T1 INT);


CREATE TABLE INPUTTAB2
(T2 INT);


WITH T AS
(SELECT * FROM INPUTTAB1
UNION
SELECT * FROM INPUTTAB2)
SELECT A1.T1||'-'||A2.T1 OUTPUT
FROM T A1
CROSS JOIN T A2
WHERE A1.T1<A2.T1;

---OR
WITH T AS
(SELECT * FROM INPUTTAB1
UNION
SELECT * FROM INPUTTAB2)
SELECT DISTINCT (LEAST(A1.T1, A2.T1) ||'-'||GREATEST(A1.T1, A2.T1)) OUTPUT
FROM T A1
CROSS JOIN T A2      
WHERE A1.T1<A2.T1
ORDER BY 1;


----36. HOW TO CREATE INDEX TO TABLE.
--- WHEN WE DEFINE CONSTRAINTS TO A TABLE ORACLE CREATES INDEX IT SELF(ORACLE DONT CREATES INDEX ITSELF IF WE ARE NOT DEFINE CONSTRAINTS TO TABLE).
--- WE CAN CREATE INDEX MANUALLY ONLY WHEN WE DEFINE IT AS "INVISIBLE". 
---IF WE DROP CONSTRAINTS, AUTOMATICALLY INDEX WILL ALSO DROP FROM TABLE(IT WILL DROP AUTOMITICALLY CREATED INDEX BY ORACLE ONLY,  IT WILL NOT DROP MANUALLY CREATED INDEX BY US).

CREATE TABLE INDEXTEST
( EMPID INT PRIMARY KEY,
EMPNAME VARCHAR2(25),
EMAIL VARCHAR2(25)
);

CREATE INDEX IDE1 ON INDEXTEST(EMPID); ---IT WILL NOT CREATE INDEX BECAUSE ALREADY ORACLE AUTOMATICALLY CREATED INDEX ITSELF.


SELECT * FROM USER_INDEXES
WHERE TABLE_NAME='INDEXTEST';

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='INDEXTEST';

ALTER TABLE INDEXTEST DROP CONSTRAINTS SYS_C009268; ----IT WILL DROP CONSTRAINTS AND ALSO DROP INDEX TOO.

CREATE INDEX IDE1 ON INDEXTEST(EMPID); ---NOW WE CAN CREATE INDEX AFTER DROPING AUTOMATICALLY GENERATED INDEX.


---37. WRITE SQL QUERY TO GET FOLLOWING RESULT.
CREATE TABLE STUDENT21
( SNAME VARCHAR2(30),
MARKS1 INT,
MARKS2 INT,
MARKS3 INT);

INSERT ALL
INTO STUDENT21 VALUES('RAGHU',90,95,82)
INTO STUDENT21 VALUES('SCOTT',85,75,65)
SELECT * FROM DUAL;

SELECT * FROM STUDENT21;

SELECT SNAME,MARKS1 MARKS FROM STUDENT21 
UNION ALL
SELECT SNAME,MARKS2 MARKS FROM STUDENT21
UNION ALL
SELECT SNAME,MARKS3 MARKS FROM STUDENT21
ORDER BY SNAME;


----38. WRITE A QUERY TO FIND THE CONSECUTIVE NUMBER.
CREATE TABLE CONSECUTIVE
(T NUMBER);

INSERT ALL
INTO CONSECUTIVE VALUES(6)
INTO CONSECUTIVE VALUES(10)
INTO CONSECUTIVE VALUES(11)
INTO CONSECUTIVE VALUES(12)
INTO CONSECUTIVE VALUES(57)
INTO CONSECUTIVE VALUES(77)
INTO CONSECUTIVE VALUES(98)
INTO CONSECUTIVE VALUES(99)
INTO CONSECUTIVE VALUES(100)
INTO CONSECUTIVE VALUES(120)
INTO SELECT * FROM DUAL; VALUES(125)
SELECT * FROM DUAL;
 
SELECT * FROM CONSECUTIVE;

SELECT T FROM (
                    SELECT T, LAG(T,1) OVER(ORDER BY T) PRV ,LEAD(T,1) OVER(ORDER BY T) NEXT   FROM CONSECUTIVE)
WHERE T=PRV+1 OR T=NEXT-1;

---OR
SELECT T FROM (
SELECT T, ROWNUM, COUNT(*) OVER(PARTITION BY (ROWNUM -T)) AS COUNT
FROM CONSECUTIVE
ORDER BY T)
WHERE COUNT >1;

---OR
SELECT c1.t
FROM CONSECUTIVE C1
JOIN CONSECUTIVE C2
ON c1.t=c2.t+1
UNION
SELECT c1.t
FROM CONSECUTIVE C1
JOIN CONSECUTIVE C2
ON c1.t=c2.t-1;


---38. WRITE QUERY TO SHOW FOLLOWING RESULT.
CREATE TABLE stu_table
(Student VARCHAR2(20),
Subject  VARCHAR2(20));

INSERT INTO stu_table VALUES('A','Science');
INSERT INTO stu_table VALUES('A','math');
INSERT INTO stu_table VALUES('A','eng');
INSERT INTO stu_table VALUES('B','Science');
INSERT INTO stu_table VALUES('B','math');
INSERT INTO stu_table VALUES('B','eng');
INSERT INTO stu_table VALUES('C','math');

SELECT * FROM stu_table;


SELECT MAX(CASE WHEN SUBJECT='Science' THEN STUDENT ELSE NULL END) SCIENCE, 
MAX(CASE WHEN SUBJECT='math' THEN STUDENT ELSE NULL END) math,
MAX(CASE WHEN SUBJECT='eng' THEN STUDENT ELSE NULL END) eng
FROM stu_table
GROUP BY STUDENT ;

---OR
SELECT science, math, eng
FROM (
SELECT student, subject,student stu_grp
FROM stu_table)
PIVOT(MAX(student) FOR subject IN ('Science' AS science,'math' AS math,'eng' AS eng))
ORDER BY stu_grp;


---39.WRITE SELECT STATEMENT TO FIND "NUMBER OF DAYS" TAKEN TO DELIVER A PRODUCT FROM ORDERD DATE.
CREATE TABLE PRODUCTDEL
( PRODUCT VARCHAR2(30),
CUSTOMER VARCHAR2(30),
STATUS VARCHAR2(30),    
STATUS_DATE DATE);


INSERT INTO PRODUCTDEL VALUES('P1','RAVI','ORDERED','01-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P1','RAVI','DISPATCHED','03-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P1','RAVI','DELIVERED','05-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P2','SRIKANTH','ORDERED','01-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P2','SRIKANTH','DISPATCHED','05-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P2','SRIKANTH','DELIVERED','10-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P1','SURESH KODI','ORDERED','01-JUL-20');
INSERT INTO PRODUCTDEL VALUES('P1','SURESH KODI','DISPATCHED','05-JUL-20');

SELECT * FROM PRODUCTDEL;

SELECT PRODUCT,CUSTOMER,
ABS(MAX(CASE WHEN STATUS = 'ORDERED' THEN TO_CHAR(STATUS_DATE,'DD') ELSE NULL END) - MAX(CASE WHEN STATUS = 'DELIVERED' THEN TO_CHAR(STATUS_DATE,'DD') ELSE NULL END)) DAYS_TO_DELIVER
FROM PRODUCTDEL 
GROUP BY PRODUCT, CUSTOMER ;


----40. WRITE A SELECT STATEMENT TO REPLICATE THE ROW MULTIPLE TIMES AS GIVEN BELOW.
WITH DT AS(
SELECT ROWNUM R FROM DUAL CONNECT BY LEVEL <= 5)
SELECT D1.R
FROM DT D1
CROSS JOIN DT D2
WHERE D1.R >= D2.R;

----41.WRITE QUERY TO SHOW RESULT AS SHOWN BELOW.

CREATE TABLE OREDERS1
(ITEM_NO NUMBER,
PKG_NO NUMBER,
ADDRESS VARCHAR2(35),
ITEM  VARCHAR2(35));

INSERT INTO OREDERS1 VALUES(5,1,'BALA','PEN');
INSERT INTO OREDERS1 VALUES(5,1,'BALA','PENCIL');
INSERT INTO OREDERS1 VALUES(5,1,'BALA','NOTPAD');
INSERT INTO OREDERS1 VALUES(6,1,'RAM','LAPTOP');
INSERT INTO OREDERS1 VALUES(6,1,'RAM','NOTEBOOK');
INSERT INTO OREDERS1 VALUES(6,1,'RAM','PC');

SELECT * FROM OREDERS1;

WITH DT AS(
SELECT ITEM_NO, PKG_NO, ADDRESS, ITEM, ROW_NUMBER() OVER(PARTITION BY ITEM_NO, PKG_NO, ADDRESS ORDER BY ROWNUM) R FROM OREDERS1)
SELECT  CASE WHEN R=1 THEN ITEM_NO ELSE NULL END ITEM_NO,
CASE WHEN R=1 THEN PKG_NO ELSE NULL END PKG_NO,
CASE WHEN R=1 THEN ADDRESS ELSE NULL END ADDRESS,
ITEM
FROM DT;


---42. CONDITIONAL CHECK CONSTRAINTS ON ONE COLUMN BASED ON OTHER COLUMN FOR EAMPLE IF "COURSE COMPLETION" COLUMN IS 'Y' THRN "COURSE COMPLETE DATE" IS MNDATORY.
CREATE TABLE STU_COURSE
(STU_ID NUMBER,
SNAME VARCHAR2(25),
COURSE_ID NUMBER,
COURSE_COMPLETED VARCHAR2(1),
COURSE_COMPLETE_DATE DATE);

INSERT INTO STU_COURSE VALUES(1,'RAVI',101,'Y',TO_DATE('01/08/2020','DD/MM/YY'));
INSERT INTO STU_COURSE VALUES(2,'RAGHU',102,'Y',TO_DATE('01/08/2020','DD/MM/YY'));
INSERT INTO STU_COURSE VALUES(3,'PRITAM',103,'Y',TO_DATE('01/08/2020','DD/MM/YY'));
INSERT INTO STU_COURSE VALUES(4,'SUDHA',101,'N',NULL);
INSERT INTO STU_COURSE VALUES(5,'MEENAKSHI',102,'N',NULL);


SELECT * FROM STU_COURSE;

ALTER TABLE STU_COURSE
ADD CONSTRAINTS C1
CHECK((NVL(COURSE_COMPLETED,'N')='N' AND COURSE_COMPLETE_DATE IS NULL) OR
       (NVL(COURSE_COMPLETED,'N')='Y' AND COURSE_COMPLETE_DATE IS NOT NULL) );

INSERT INTO STU_COURSE VALUES(6,'SIVA',102,'N',SYSDATE);---Check Constraint (Chetu.C1) Violated.
INSERT INTO STU_COURSE VALUES(7,'SURYA',103,NULL,SYSDATE);---Check Constraint (Chetu.C1) Violated.
INSERT INTO STU_COURSE VALUES(8,'RAMESH',103,'Y',SYSDATE);---ACCEPTED HERE EVERYTHING AS PER CHECK CONSTRAINT.
INSERT INTO STU_COURSE VALUES(9,'SOMU',104,'Y',NULL);---Check Constraint (Chetu.C1) Violated.

UPDATE STU_COURSE
SET COURSE_COMPLETED ='Y'
WHERE STU_ID=5;---Check Constraint (Chetu.C1) Violated BECAUSE DATE NOT UPDATED HERE

UPDATE STU_COURSE
SET COURSE_COMPLETED ='Y',course_complete_date=SYSDATE
WHERE STU_ID=5;---ACCEPTED HERE EVERYTHING AS PER CHECK CONSTRAINT.


---43.CREATING UNIQUE INDEX TO A TABLE.
CREATE TABLE UNIQUEINDEX
(EMPNO NUMBER,
ENAME VARCHAR2(25),
JOB VARCHAR2(25));

INSERT INTO UNIQUEINDEX VALUES(1,'KING','CEO');
INSERT INTO UNIQUEINDEX VALUES(2,'BLAKE','MANAGER');
INSERT INTO UNIQUEINDEX VALUES(3,'ROY','MANAGER');
INSERT INTO UNIQUEINDEX VALUES(4,'BUTTLER','MANAGER');

SELECT * FROM UNIQUEINDEX;

CREATE UNIQUE INDEX UI ON UNIQUEINDEX
( CASE WHEN JOB = 'CEO' THEN JOB 
                        ELSE NULL END);

INSERT INTO UNIQUEINDEX VALUES(5,'RAMU','CEO');---UNIQUE CONSTRAINT (chetu.ui) violated ONLY ONE CEO IS ALLOWED IN "JOB" COLUMN
UPDATE UNIQUEINDEX SET JOB ='MANAGER' WHERE EMPNO=1;---HERE WE UPDATED "KING" AS "MANAGER".
INSERT INTO UNIQUEINDEX VALUES(5,'RAMU','CEO');---NOW JOB COLUMN ACCEPTED "CEO" BECAUSE WE UPDATED "KING" AS "MANAGER" SO NO "CEO" IN JOB COLUMN.


---44.WRITE A QUERY TO FIND THE PARENT HAVING EXACTLY ONE "MALE" CHILD AND ONE "FEMALE" CHILD
CREATE TABLE CHILDGENDER
( PARENT_ID NUMBER,
CHILD_GENDER VARCHAR2(25));

INSERT INTO CHILDGENDER VALUES(1,'MALE');
INSERT INTO CHILDGENDER VALUES(1,'MALE');
INSERT INTO CHILDGENDER VALUES(1,'FEMALE');
INSERT INTO CHILDGENDER VALUES(2,'FEMALE');
INSERT INTO CHILDGENDER VALUES(2,'FEMALE');
INSERT INTO CHILDGENDER VALUES(2,'MALE');
INSERT INTO CHILDGENDER VALUES(3,'FEMALE');
INSERT INTO CHILDGENDER VALUES(3,'MALE');
INSERT INTO CHILDGENDER VALUES(4,'MALE');
INSERT INTO CHILDGENDER VALUES(5,'FEMALE');
INSERT INTO CHILDGENDER VALUES(6,'FEMALE');
INSERT INTO CHILDGENDER VALUES(6,'MALE');
INSERT INTO CHILDGENDER VALUES(7,'FEMALE');
INSERT INTO CHILDGENDER VALUES(7,'FEMALE');

SELECT * FROM PARENT_ID;

---STEP:1.
SELECT PARENT_ID,COUNT(*),COUNT(CASE WHEN CHILD_GENDER='MALE' THEN '1' END) MALE_COUNT,
COUNT(CASE WHEN CHILD_GENDER='FEMALE' THEN '1' END) FEMALE_COUNT FROM CHILDGENDER
GROUP BY PARENT_ID
HAVING COUNT(CASE WHEN CHILD_GENDER='MALE' THEN '1' END)=1 AND COUNT(CASE WHEN CHILD_GENDER='FEMALE' THEN '1' END)=1 ;

---STEP:2.
SELECT PARENT_ID FROM CHILDGENDER
GROUP BY PARENT_ID
HAVING COUNT(CASE WHEN CHILD_GENDER='MALE' THEN '1' END)=1 AND COUNT(CASE WHEN CHILD_GENDER='FEMALE' THEN '1' END)=1 ;


----OR

SELECT PARENT_ID FROM(
                    SELECT PARENT_ID,COUNT(CASE WHEN CHILD_GENDER='MALE' THEN '1' END) MALE_COUNT FROM CHILDGENDER
                    GROUP BY PARENT_ID
                    HAVING COUNT(CASE WHEN CHILD_GENDER='MALE' THEN '1' END)=1
                    UNION ALL
                    SELECT PARENT_ID,COUNT(CASE WHEN CHILD_GENDER='FEMALE' THEN '1' END) MALE_COUNT FROM CHILDGENDER
                    GROUP BY PARENT_ID
                    HAVING COUNT(CASE WHEN CHILD_GENDER='FEMALE' THEN '1' END) = 1)
GROUP BY PARENT_ID,MALE_COUNT
HAVING COUNT(PARENT_ID)=2;

SELECT DISTINCT PARENT_ID FROM (
                SELECT PARENT_ID,CHILD_GENDER,COUNT(1) OVER(PARTITION BY PARENT_ID) C,
                COUNT(CASE WHEN CHILD_GENDER='MALE' THEN '1' END) OVER(PARTITION BY PARENT_ID) M,
                COUNT(CASE WHEN CHILD_GENDER='FEMALE' THEN '1' END) OVER(PARTITION BY PARENT_ID) F
                FROM CHILDGENDER)
WHERE M=1 AND F=1;


----45.INPUT VALUE "ABCD" & MAX SEQUENCE:4. WRITE A SQL TO GENERATE ALPHA-NUMERIC SEQUENCE AS GIVEN HERE.

WITH D AS(SELECT 'ABCD' STR, 4 AS SEQ FROM DUAL)
SELECT S||L STR FROM(
            SELECT LEVEL L FROM D
            CONNECT BY LEVEL<=SEQ),
                    (SELECT SUBSTR(STR,ROWNUM,1) S FROM D
                CONNECT BY LEVEL <=LENGTH(STR));

----OR
WITH D AS(SELECT 'ABCD' STR, 4 AS SEQ FROM DUAL)
SELECT STR C1,
CEIL(LEVEL/LENGTH(STR)) C2,
MOD(LEVEL,LENGTH(STR))+1 C3,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1) C4,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1)||CEIL(LEVEL/LENGTH(STR)) C5
FROM D
CONNECT BY LEVEL<=LENGTH(STR)*SEQ
ORDER BY 2,3;

---SOME SAMPLE EAMPLES
---1. "ABC" AND SEQUENCE "3".
WITH D AS(SELECT 'ABC' STR, 3 AS SEQ FROM DUAL)
SELECT STR C1,
CEIL(LEVEL/LENGTH(STR)) C2,
MOD(LEVEL,LENGTH(STR))+1 C3,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1) C4,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1)||CEIL(LEVEL/LENGTH(STR)) C5
FROM D
CONNECT BY LEVEL<=LENGTH(STR)*SEQ
ORDER BY 2,3;

---2."A" AND SEQUENCE IS "1"
WITH D AS(SELECT 'A' STR, 1 AS SEQ FROM DUAL)
SELECT STR C1,
CEIL(LEVEL/LENGTH(STR)) C2,
MOD(LEVEL,LENGTH(STR))+1 C3,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1) C4,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1)||CEIL(LEVEL/LENGTH(STR)) C5
FROM D
CONNECT BY LEVEL<=LENGTH(STR)*SEQ
ORDER BY 2,3;

---3."AB" AND SEQUENCE IS "10"
WITH D AS(SELECT 'AB' STR, 10 AS SEQ FROM DUAL)
SELECT STR C1,
CEIL(LEVEL/LENGTH(STR)) C2,
MOD(LEVEL,LENGTH(STR))+1 C3,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1) C4,
SUBSTR(STR,MOD(LEVEL,LENGTH(STR))+1,1)||CEIL(LEVEL/LENGTH(STR)) C5
FROM D
CONNECT BY LEVEL<=LENGTH(STR)*SEQ
ORDER BY 2,3;


---46.WRITE SQL TO GENERATE THE CUMULATIVE SUM OF "DEBIT" AND "CREDIT" BALANCE AS GIVEN BELOW.

CREATE TABLE CREDITDEBIT
(ID NUMBER,
TYPE VARCHAR2(1),
AMOUNT NUMBER);

INSERT INTO CREDITDEBIT VALUES(1,'C',10000);
INSERT INTO CREDITDEBIT VALUES(2,'D',2000);
INSERT INTO CREDITDEBIT VALUES(3,'C',10000);
INSERT INTO CREDITDEBIT VALUES(4,'D',5000);
INSERT INTO CREDITDEBIT VALUES(5,'D',4000);

SELECT * FROM CREDITDEBIT;
SELECT ID, TYPE, AMOUNT,SUM(ORIGINAL_AMT) OVER(ORDER BY ID) CUMMELATIVE_SUM FROM(
                    SELECT ID, TYPE, AMOUNT,(CASE WHEN TYPE='D' THEN AMOUNT*-1  
                                                    WHEN TYPE='C' THEN AMOUNT*1 ELSE NULL  END) ORIGINAL_AMT
                    FROM CREDITDEBIT);
                    

----47. WRITE SQL QUERY TO TRANSFORM THE DATA AS GIVEN BELOW.
CREATE TABLE MOBILENUMTRANS
(NAME VARCHAR2(25),
HOME_PH NUMBER,
WORK_NO NUMBER,
MOBILE_NO NUMBER);

INSERT INTO MOBILENUMTRANS VALUES('YOGESH',NULL,NULL,1111122222);
INSERT INTO MOBILENUMTRANS VALUES('DINESH',3333344444,NULL,5555566666);
INSERT INTO MOBILENUMTRANS VALUES('SACHIN',NULL,7777788888,NULL);

SELECT * FROM MOBILENUMTRANS;


SELECT NAME,NUMBER_TYPE,CONTACT_NUMBER FROM (
                SELECT NAME, 'HOME_NO' AS NUMBER_TYPE, HOME_PH AS CONTACT_NUMBER FROM MOBILENUMTRANS
                UNION ALL
                SELECT NAME, 'MOBILE_NO' AS NUMBER_TYPE, MOBILE_NO AS CONTACT_NUMBER FROM MOBILENUMTRANS
                UNION ALL
                SELECT NAME, 'WORK_NO' AS NUMBER_TYPE, WORK_NO AS CONTACT_NUMBER FROM MOBILENUMTRANS)
WHERE CONTACT_NUMBER IS NOT NULL;

----OR
SELECT * FROM (
            SELECT * FROM MOBILENUMTRANS)
UNPIVOT ( CONTACT_NUMBER FOR NUMBER_TYPE IN (HOME_PH,WORK_NO, MOBILE_NO));


----48.WRITE QUERY TO SHOW RESLT AS SHOWN BELOW.

CREATE TABLE BANKTRANSATIONS
(ACCT_HEAD VARCHAR2(30),
TRANS_YEAR NUMBER,
JAN NUMBER,
FEB NUMBER,
MAR NUMBER,
APR NUMBER,
MAY NUMBER,
JUN NUMBER,
JUL NUMBER,
AUG NUMBER,
SEP NUMBER,
OCT NUMBER,
NOV NUMBER,
DEC NUMBER);

SELECT * FROM BANKTRANSATIONS;

SELECT ACCT_HEAD, TRANS_YEAR, MONTH, TRANS_AMOUNT, SUM(TRANS_AMOUNT) OVER(PARTITION BY ACCT_HEAD, TRANS_YEAR ORDER BY TO_DATE(MONTH,'MON')) CUM_SUM
FROM(
SELECT ACCT_HEAD, TRANS_YEAR, 
NVL(JAN,0) JAN, NVL(FEB,0) FEB, NVL(MAR,0) MAR, NVL(APR,0) APR, NVL(MAY,0) MAY, NVL(JUN,0) JUN, NVL(JUL,0) JUL, NVL(AUG,0) AUG, NVL(SEP,0) SEP, NVL(OCT,0) OCT, NVL(NOV,0) NOV, NVL(DEC,0) DEC 
FROM BANKTRANSATIONS)
UNPIVOT (TRANS_AMOUNT FOR MONTH IN (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC));



----49. WRITE A QUERY TO SHOW OUTPUT AS IN THE ORDER "HR_REP","FI_ACCOUNT","IT_PROG","AD_PRES" AFTER FOLLOW REMAINING AS PER JOB_ID.
SELECT SORTEDJOB FROM(
SELECT DISTINCT job_id SORTEDJOB, (CASE WHEN JOB_ID='HR_REP' THEN '1' 
                              WHEN JOB_ID='FI_ACCOUNT' THEN '2'  
                              WHEN JOB_ID='IT_PROG' THEN '3'  
                              WHEN JOB_ID='AD_PRES' THEN '4'  
                              ELSE '5' END) SORTED_JOB_ID 
FROM employees
ORDER BY SORTED_JOB_ID,JOB_ID);


/*----50.A TABLE CONTAIN "ACCOUNT_ID","CARD_ID","STATUS_DATE". AN ACCOUNT CAN HAVE MULTIPLE CARDS, HOWEVER ONLY ONE CARD IS IN "ACTIVE" STATUS
AND REMAINING CARDS ARE "CANCELLED" STATUS.
--WRITE A QUERY TO FIND THE ACTIVE CARD OF EACH ACCOUNT. IF NO ACTIVE CARDS FOUND, THEN RETURN LAST CACELLED CARDS.*/
CREATE TABLE CARDS
(ACCT_ID VARCHAR2(25),
CARD_ID VARCHAR2(25),
STATUS VARCHAR2(25),
STATUS_DATE DATE);

SELECT * FROM CARDS;

SELECT ACCT_ID, NVL(MAX(ACTIVE), MAX(LAST_CANCELLED_CARD)) ACT_CARD_OR_LAST_CANCEL_CARD  FROM (
SELECT ACCT_ID, ---CARD_ID, STATUS,STATUS_DATE,
(CASE WHEN STATUS='ACTIVE' THEN CARD_ID ELSE NULL END) ACTIVE,
CASE WHEN STATUS_DATE = MAX(CASE WHEN STATUS='CANCELLED' THEN STATUS_DATE ELSE NULL END) OVER(PARTITION BY ACCT_ID) THEN CARD_ID END  LAST_CANCELLED_CARD
FROM CARDS)
GROUP BY ACCT_ID;
                  

----51.QUERY TO FIND SUM OF POSITIVE AND NEGATIVE NUMBERS.
CREATE TABLE POSITIVENEGATIVE
(COL1 NUMBER);

SELECT * FROM POSITIVENEGATIVE;

SELECT SUM(CASE WHEN COL1>0 THEN COL1 END) POSITIVE,
        SUM(CASE WHEN COL1<0 THEN COL1 END) NEGATIVE
FROM POSITIVENEGATIVE;

----OR
SELECT SUM(DECODE(SIGN(COL1),1,COL1)) POSITIVE,SUM(DECODE(SIGN(COL1),-1,COL1)) NEGATIVE
FROM POSITIVENEGATIVE;

---OR
SELECT 
(SELECT SUM(COL1) FROM POSITIVENEGATIVE WHERE COL1>0) POSITIVE,
(SELECT SUM(COL1) FROM POSITIVENEGATIVE WHERE COL1<0) NEGATIVE
FROM DUAL;

---OR
SELECT DECODE(SIGN(COL1),1,'POSITIVE',-1,'NEGATIVE') SIGN, SUM(COL1) 
FROM POSITIVENEGATIVE
GROUP BY DECODE(SIGN(COL1),1,'POSITIVE',-1,'NEGATIVE');

---OR
SELECT 'POSITIVE' SIGN, SUM(COL1) FROM POSITIVENEGATIVE WHERE COL1>0
UNION ALL
SELECT 'NEGATIVE' SIGN, SUM(COL1) FROM POSITIVENEGATIVE WHERE COL1<0;


---52. WRITE SQL TO FIND NUMBER OF OCCURANCE OF 'A' OR 'a' IN STRING.
WITH DT AS(
SELECT 'AAAHKDJSHaskjriihaakdj' D FROM DUAL)
SELECT REGEXP_COUNT(LOWER(D), 'a') count  FROM DT;

----OR
WITH DT AS(
SELECT 'AAAHKDJSHaskjriihaakdj' D FROM DUAL)
SELECT LENGTH(LOWER(D))-LENGTH(REPLACE(LOWER(D),'a','')) count  FROM DT;


---53. WRITE AN SQL TO PRINT "SEQUENCE NUMBER" AS GIVEN HERE.
SELECT MOD(ROWNUM,2)
FROM DUAL CONNECT BY LEVEL<=10;
---OR
SELECT LISTAGG(MOD(ROWNUM,2),',') WITHIN GROUP (ORDER BY ROWNUM) 
FROM DUAL CONNECT BY LEVEL<=10;



SELECT CASE WHEN MOD(ROWNUM,3)=0 THEN 3 ELSE MOD(ROWNUM,3) END
FROM DUAL CONNECT BY LEVEL<=10;
---OR
SELECT LISTAGG(CASE WHEN MOD(ROWNUM,3)=0 THEN 3 ELSE MOD(ROWNUM,3) END) WITHIN GROUP (ORDER BY ROWNUM) 
FROM DUAL CONNECT BY LEVEL<=10;

SELECT CASE WHEN MOD(ROWNUM,4)=0 THEN 4 ELSE MOD(ROWNUM,4) END
FROM DUAL CONNECT BY LEVEL<=10;
---OR
SELECT LISTAGG(CASE WHEN MOD(ROWNUM,4)=0 THEN 4 ELSE MOD(ROWNUM,4) END) WITHIN GROUP (ORDER BY ROWNUM) 
FROM DUAL CONNECT BY LEVEL<=10;




----54.WRITE SQL TO FIND THE FIRST "CHARACTER" THAT OCCURED SECOND TIME IN GIVEN STRING.
---EXAMPLE "BLUEBERRY".
WITH DT AS(
SELECT 'BLUEBERRY' D,ROWNUM FROM DUAL)
SELECT   COL1 FROM(
        SELECT ROWNUM, COL1, D, NO_OF_OCCURANCE, ROW_NUMBER() OVER(PARTITION BY COL1 ORDER BY ROWNUM) RANK  FROM (
                                     SELECT ROWNUM,SUBSTR(D,ROWNUM,1) COL1,D,REGEXP_COUNT(D,SUBSTR(D,ROWNUM,1)) NO_OF_OCCURANCE FROM DT
                                         CONNECT BY LEVEL <=LENGTH(D))
                                         WHERE NO_OF_OCCURANCE>=2 
                                         ORDER BY ROWNUM)
WHERE RANK>=2 AND ROWNUM=1;

----EXAMPLE "MUSHROOM"
WITH DT AS(
SELECT 'MUSHROOM' D,ROWNUM FROM DUAL)
SELECT   COL1 FROM(
        SELECT ROWNUM, COL1, D, NO_OF_OCCURANCE, ROW_NUMBER() OVER(PARTITION BY COL1 ORDER BY ROWNUM) RANK  FROM (
                                     SELECT ROWNUM,SUBSTR(D,ROWNUM,1) COL1,D,REGEXP_COUNT(D,SUBSTR(D,ROWNUM,1)) NO_OF_OCCURANCE FROM DT
                                         CONNECT BY LEVEL <=LENGTH(D))
                                         WHERE NO_OF_OCCURANCE>=2 
                                         ORDER BY ROWNUM)
WHERE RANK>=2 AND ROWNUM=1;
                                       
                                      
----EXAMPLE "COCONUT"
WITH DT AS(
SELECT 'COCONUT' D,ROWNUM FROM DUAL)
SELECT   COL1 FROM(
        SELECT ROWNUM, COL1, D, NO_OF_OCCURANCE, ROW_NUMBER() OVER(PARTITION BY COL1 ORDER BY ROWNUM) RANK  FROM (
                                     SELECT ROWNUM,SUBSTR(D,ROWNUM,1) COL1,D,REGEXP_COUNT(D,SUBSTR(D,ROWNUM,1)) NO_OF_OCCURANCE FROM DT
                                         CONNECT BY LEVEL <=LENGTH(D))
                                         WHERE NO_OF_OCCURANCE>=2 
                                         ORDER BY ROWNUM)
WHERE RANK>=2 AND ROWNUM=1;

                                     
----EXAMPLE "BANANA"
WITH DT AS(
SELECT 'BANANA' D,ROWNUM FROM DUAL)
SELECT   COL1 FROM(
        SELECT ROWNUM, COL1, D, NO_OF_OCCURANCE, ROW_NUMBER() OVER(PARTITION BY COL1 ORDER BY ROWNUM) RANK  FROM (
                                     SELECT ROWNUM,SUBSTR(D,ROWNUM,1) COL1,D,REGEXP_COUNT(D,SUBSTR(D,ROWNUM,1)) NO_OF_OCCURANCE FROM DT
                                         CONNECT BY LEVEL <=LENGTH(D))
                                         WHERE NO_OF_OCCURANCE>=2 
                                         ORDER BY ROWNUM)
WHERE RANK>=2 AND ROWNUM=1;



---55.GIVEN "YEAR" 2024 AS INPUT WRITE A SQL TO PRINT THE "MONTH" AND "NUMBER OF DAYS" IN EACH MONTH.
---EXAMPLE "2024".

WITH DS AS( SELECT 2024 AS Y FROM DUAL)
SELECT---Y ,LAST_DAY(TO_DATE(TRIM(TO_CHAR(LEVEL,'00'))||Y ,'MMYYYY')),
LEVEL MM,
TO_CHAR(LAST_DAY(TO_DATE(TRIM(TO_CHAR(LEVEL,'00'))||Y ,'MMYYYY')),'MON') MONTH_NAME,
TO_CHAR(LAST_DAY(TO_DATE(TRIM(TO_CHAR(LEVEL,'00'))||Y ,'MMYYYY')),'DD') NO_OF_DAYS
FROM DS
CONNECT BY LEVEL <=12;

---EXAMPLE "2023".

WITH DS AS( SELECT 2023 AS Y FROM DUAL)
SELECT---Y ,LAST_DAY(TO_DATE(TRIM(TO_CHAR(LEVEL,'00'))||Y ,'MMYYYY')),
LEVEL MM,
TO_CHAR(LAST_DAY(TO_DATE(TRIM(TO_CHAR(LEVEL,'00'))||Y ,'MMYYYY')),'MON') MONTH_NAME,
TO_CHAR(LAST_DAY(TO_DATE(TRIM(TO_CHAR(LEVEL,'00'))||Y ,'MMYYYY')),'DD') NO_OF_DAYS
FROM DS
CONNECT BY LEVEL <=12;



----56.WRITE A SQL QUERY TO INSERT SPACE AFTER EACH CHARACTER IN STRING USING "REGULAR EXPRESSION" AND WITHOUT USING "REGULAR EXPRESSION"..

SELECT REGEXP_REPLACE(FIRST_NAME,'(.)','\1 ') FROM EMPLOYEES;---IT RETURNS "SPACE" BETWEEN EVERY CHARACTER.

SELECT REGEXP_REPLACE(FIRST_NAME,'(.)','\1*') FROM EMPLOYEES; ---IT RETURNS "*" BETWEEN EVERY CHARACTER.

SELECT REGEXP_REPLACE(FIRST_NAME,'(.)','\1-->') FROM EMPLOYEES; ---IT RETURNS "-->" BETWEEN EVERY CHARACTER.


---WITHOUT USING "REGEXP_REPLACE".
---STEP 1:
WITH DT AS(
SELECT 'ORACLE' O FROM DUAL)
SELECT O, LISTAGG(DT) WITHIN GROUP(ORDER BY L) FROM(
SELECT O ,SUBSTR(O,LEVEL,1)||'.'  DT,LEVEL L FROM DT
CONNECT BY LEVEL <=LENGTH(O))
GROUP BY O ;


---STEP 2:
WITH DT AS(
SELECT 'ORACLE' O FROM DUAL)
SELECT LISTAGG(DT) WITHIN GROUP(ORDER BY L) FROM(
SELECT O ,SUBSTR(O,LEVEL,1)||' '  DT,LEVEL L FROM DT----REPLACE "." BY SPACE(' ').
CONNECT BY LEVEL <=LENGTH(O))
GROUP BY O ;


/*----57. WRITE A SQL TO CHECK VALID DATES IN GIVEN LIST OF DATE.
CREATE TABLE DATEVALIDATION
( DATES VARCHAR2(30));

INSERT INTO DATEVALIDATION VALUES('26-FEB-2021');
INSERT INTO DATEVALIDATION VALUES('27-FEB-2021');
INSERT INTO DATEVALIDATION VALUES('28-FEB-2021');
INSERT INTO DATEVALIDATION VALUES('29-FEB-2021');
INSERT INTO DATEVALIDATION VALUES('30-FEB-2021');
INSERT INTO DATEVALIDATION VALUES('30-JUN-2021');
INSERT INTO DATEVALIDATION VALUES('31-JUN-2021');
INSERT INTO DATEVALIDATION VALUES('32-JUN-2021');

SELECT * FROM DATEVALIDATION;

SELECT DATES, VALIDATE_CONVERSION(DATES AS DATE,'DD-MON-YYYY') FROM DATEVALIDATION; ---IT IS AVAILABLE FROM "12C" ORACLE VERSION ONLY.*/


----58.WRITE SQL TO FIND GIVEN STRINGS ARE VALID ANAGRAM OR NOT.
---EXAMPLE 1:  "HEART", "EARTH"
WITH DT AS(
SELECT 'EARTH' S1, 'HEART' AS S2 FROM DUAL)
SELECT S1,S2,
        ---SUBSTR(S1,LEVEL,1),
        ---SUBSTR(S2,LEVEL,1),
        SUM(ORA_HASH(SUBSTR(S1,LEVEL,1))) ORA_HASH1,
        SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) ORA_HASH2,
        CASE WHEN SUM(ORA_HASH(SUBSTR(S1,LEVEL,1)))= SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) THEN 'VALID ANAGRAM' ELSE 'NOT ANAGRAM' END AS OUTPUT
FROM DT
CONNECT BY LEVEL <= LENGTH(S1)
GROUP BY S1,S2;


---EXAMPLE 2:  "SILENT", "LISTEN"
WITH DT AS(
SELECT 'SILENT' S1, 'LISTEN' AS S2 FROM DUAL)
SELECT S1,S2,
        ---SUBSTR(S1,LEVEL,1),
        ---SUBSTR(S2,LEVEL,1),
        SUM(ORA_HASH(SUBSTR(S1,LEVEL,1))) ORA_HASH1,
        SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) ORA_HASH2,
        CASE WHEN SUM(ORA_HASH(SUBSTR(S1,LEVEL,1)))= SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) THEN 'VALID ANAGRAM' ELSE 'NOT ANAGRAM' END AS OUTPUT
FROM DT
CONNECT BY LEVEL <= LENGTH(S1)
GROUP BY S1,S2;


---EXAMPLE 3:  "A GENTLEMAN", "ELEGANT MAN"
WITH DT AS(
SELECT 'ELEGANT MAN' S1, 'A GENTLEMAN' AS S2 FROM DUAL)
SELECT S1,S2,
        ---SUBSTR(S1,LEVEL,1),
        ---SUBSTR(S2,LEVEL,1),
        SUM(ORA_HASH(SUBSTR(S1,LEVEL,1))) ORA_HASH1,
        SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) ORA_HASH2,
        CASE WHEN SUM(ORA_HASH(SUBSTR(S1,LEVEL,1)))= SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) THEN 'VALID ANAGRAM' ELSE 'NOT ANAGRAM' END AS OUTPUT
FROM DT
CONNECT BY LEVEL <= LENGTH(S1)
GROUP BY S1,S2;


---EXAMPLE 4:  "APPLE", "ORANGE"
WITH DT AS(
SELECT 'APPLE' S1, 'ORANGE' AS S2 FROM DUAL)
SELECT S1,S2,
        ---SUBSTR(S1,LEVEL,1),
        ---SUBSTR(S2,LEVEL,1),
        SUM(ORA_HASH(SUBSTR(S1,LEVEL,1))) ORA_HASH1,
        SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) ORA_HASH2,
        CASE WHEN SUM(ORA_HASH(SUBSTR(S1,LEVEL,1)))= SUM(ORA_HASH(SUBSTR(S2,LEVEL,1))) THEN 'VALID ANAGRAM' ELSE 'NOT ANAGRAM' END AS OUTPUT
FROM DT
CONNECT BY LEVEL <= LENGTH(S1)
GROUP BY S1,S2;

/* ---1.HERE IF WE "ASCII" VALUE WE WILL NOT GET CORRECT RESULT IN ALL THE CASES BECAUSE ASCII ARE CONTINOUS NUMBER(NOT NON CONTINOUS) MAY GIVE SAME SUM FOR "NON ANAGRAM" STRINGS ALSO.
---2. TO OVER COME WE USED "ORA_HASH" TO FIND "ANAGRAM STRINGS".*/
SELECT 64+ LEVEL, CHR(64+ LEVEL), ASCII(CHR(64+ LEVEL)), ORA_HASH(CHR(64+ LEVEL))
FROM DUAL
CONNECT BY LEVEL <=26;


/*----59. WRITE A QUERY TO RE-ORDER THE GIVEN NUMBER ACCORDING TO ASCENDING NUMBER.
CREATE TABLE ASCENDINGNUMBER
(
VALU NUMBER);

INSERT INTO ASCENDINGNUMBER VALUES(12453);
INSERT INTO ASCENDINGNUMBER VALUES(5684);
INSERT INTO ASCENDINGNUMBER VALUES(4556689);

SELECT * FROM ASCENDINGNUMBER;

SELECT VALU, ROWNUM FROM ASCENDINGNUMBER
CONNECT BY LEVEL <= LENGTH(VALU);*/


----60.MASK USER DATA WITH RANDOM DATA.
/*---1).INPUT IS "KA33456" OUT PUT IS "KA+RANDOM CHARACTER+ NUMBERS"
----LOGIC IS FIRST TWO CHARACTER REMAIN SAME AND THEN ONE RANDOM ALPHABET AND THEN SOME RANDOM NUMBER. LENGTH SHOULD BE REMAIN SAME.*/
WITH DS AS (SELECT 'KA33456' D FROM DUAL)
SELECT D, SUBSTR(D,1,2)||DBMS_RANDOM.STRING('U',1)||SUBSTR(SUBSTR(DBMS_RANDOM.VALUE,2),1,LENGTH(D)-3) OUTPUT 
FROM DS;

---2).INPUT VALUE IS "RAVI PRASAD" OUTPUT IS "RA+'RANDOM NMBER'"
WITH DT AS( SELECT 'RAVI PRASAD' D FROM DUAL)
SELECT D,SUBSTR(D,1,2)||SUBSTR(SUBSTR(DBMS_RANDOM.VALUE,2),1,LENGTH(D)-2) OUTPUT FROM DT;


---3). INPUT IS "SIVA.K.ACADEMY@GMAIL.COM" AND EXPECTED OUTPUT IS "SI+RANDOMNUMBER+@GMAIL.COM".
WITH DT AS(SELECT 'SIVA.K.ACADEMY@GMAIL.COM'  D FROM DUAL)
---SELECT LENGTH(D),LENGTH(OUTPUT) FROM ( ----HERE LENGTH IS USED TO CHECK FINAL OUTPUT LENGTH MATCHES WITH STRING LENGTH OR NOT
SELECT D,SUBSTR(D,1,2)||SUBSTR(SUBSTR(DBMS_RANDOM.VALUE,2),1,ABS(LENGTH(D)-LENGTH(SUBSTR(D,1,2))-LENGTH(SUBSTR(D,INSTR(D,'@',1)))))||SUBSTR(D,INSTR(D,'@',1)) OUTPUT 
FROM DT;


----61. FIND THE LAST_DAY OF THE MONTH WITHOUT USING "LAST_DAY" FUNCTION.
WITH DT AS(
SELECT TO_DATE('14-02-2020','DD-MM-YYYY') D FROM DUAL)
SELECT D, LAST_DAY(D), ADD_MONTHS(TRUNC(D,'MONTH'),1)-1 OUTPUT FROM DT;


---62. CAN WE CREATE "PRIMARY KEY", "NOT NULL", "UNIQUE" CONSTRAINTS ON SAME COLUMN.
---WE CAN CREATE "PRIMARY KEY" AND  "NOT NULL" TO SAME COLUMN.
---WE CAN NOT CREATE "PRIMARY KEY" AND  "UNIQUE" TO SAME COLUMN.
---WE CAN NOT CREATE "PRIMARY KEY","NOT NULL" AND  "UNIQUE" TO SAME COLUMN.

----63.FIND AVERAGE DISTANCE OF SOURCE AND DESTINATIONS.
create table src_dest_dist
(
    src         varchar(20),
    dest        varchar(20),
    distance    float
);
insert into src_dest_dist values ('A', 'B', 21);
insert into src_dest_dist values ('B', 'A', 28);
insert into src_dest_dist values ('A', 'B', 19);
insert into src_dest_dist values ('C', 'D', 15);
insert into src_dest_dist values ('C', 'D', 17);
insert into src_dest_dist values ('D', 'C', 16.5);
insert into src_dest_dist values ('D', 'C', 18);

select * from src_dest_dist;

select least(SRC, DEST), greatest(SRC, DEST),round(avg(distance),2) from src_dest_dist
group by least(SRC, DEST), greatest(SRC, DEST);



----64
-->> Problem Statement:
/*Suppose you have a car travelling certain distance and the data is presented as follows -
Day 1 - 50 km
Day 2 - 100 km
Day 3 - 200 km

Now the distance is a cumulative sum as in
    row2 = (kms travelled on that day + row1 kms).

How should I get the table in the form of kms travelled by the car on a given day and not the sum of the total distance?
*/
create table car_travels
(
    cars                    varchar(40),
    days                    varchar(10),
    cumulative_distance     int
);

insert into car_travels values ('Car1', 'Day1', 50);
insert into car_travels values ('Car1', 'Day2', 100);
insert into car_travels values ('Car1', 'Day3', 200);
insert into car_travels values ('Car2', 'Day1', 0);
insert into car_travels values ('Car3', 'Day1', 0);
insert into car_travels values ('Car3', 'Day2', 50);
insert into car_travels values ('Car3', 'Day3', 50);
insert into car_travels values ('Car3', 'Day4', 100);

select * from car_travels;


->> Solution:
select cumulative_distance-lag(cumulative_distance, 1, 0) over(partition by cars order by days) as distance_travelled
from car_travels;



----65.WRITE A QUERY TO FETCH THE RECORD OF BRAND WHOSE AMOUNT IS INCREASING EVERY YEAR.
-->> Dataset:
drop table brands;
create table brands
(
    Year    int,
    Brand   varchar(20),
    Amount  int
);


insert into brands values (2018, 'Apple', 45000);
insert into brands values (2019, 'Apple', 35000);
insert into brands values (2020, 'Apple', 75000);
insert into brands values (2018, 'Samsung',	15000);
insert into brands values (2019, 'Samsung',	20000);
insert into brands values (2020, 'Samsung',	25000);
insert into brands values (2018, 'Nokia', 21000);
insert into brands values (2019, 'Nokia', 17000);
insert into brands values (2020, 'Nokia', 14000);

select * from brands;

with cte as
    (select brand,(case when amount < lead(amount, 1, amount+1)
                                over(partition by brand order by year)
                then 1
           else 0
      end) as flag
    from brands)
select *
from brands
where brand not in (select brand from cte where flag = 0);


    


COMMIT;
select * from employees;
select * from departments;