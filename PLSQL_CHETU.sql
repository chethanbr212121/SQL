/* 1.WHAT ARE VARIABLES.
--VARIABLES ARE PLACE HOLDER IN MEMORY THAT HOLD SOME DATA. THE VALUE THEY HOLD IS OF VARIABLE NATURE CAN BE CHANGE ANY TIME.
--EVERY VARIABLE MUST HAVE VALID NAME, DATATYPE AND DATA WIDTH. VARIABLE MUST DECLARE PREIOR TO IT'S USE*/
SET SERVEROUTPUT ON;
DECLARE
 V_TEST VARCHAR2(25);
 BEGIN
 V_TEST := 'CHETHAN';
    DBMS_OUTPUT.PUT_LINE(V_TEST);
END;


/*--HERE VARIABLE "V_SALARY" CAN HOLD ONLY ONE DATA AT A TIME THUS MAKE SURE YOUR SELECT STATEMENT WILL RETURN DATA FROM ONE ROW AT A TIME.
YOU CAN ENSURE THIS BY USING WHERE CLAUSE.*/
SET SERVEROUTPUT ON;
DECLARE 
    V_SALARY NUMBER(10);
    BEGIN
    SELECT SALARY INTO V_SALARY FROM EMPLOYEES
    WHERE EMPLOYEE_ID=100;
    DBMS_OUTPUT.PUT_LINE(V_SALARY);
    END;
/

SET SERVEROUTPUT ON;
DECLARE 
    V_SALARY NUMBER(10);
    V_FNAME VARCHAR2(20);
    BEGIN
    SELECT SALARY,FIRST_NAME INTO V_SALARY,V_FNAME FROM EMPLOYEES
    WHERE EMPLOYEE_ID=100;
    DBMS_OUTPUT.PUT_LINE(V_FNAME ||' HAS SALARY'||' ' || V_SALARY);
    END;
/

----ANCHORED DATA TYPE (%TYPE).
---THESE ARE DATA TYPE WHICH YOU ASSIGN TO A VARIABLE BASED ON A DATABASE OBJECT.
---SYNTAX = VARIABLE-NAME TYPED-ATTRIBUTE %TYPE.
SET SERVEROUTPUT ON;
DECLARE 
    V_FNAME EMPLOYEES.FIRST_NAME%TYPE;
    BEGIN
    SELECT FIRST_NAME INTO V_FNAME FROM EMPLOYEES
    WHERE EMPLOYEE_ID=100;
    DBMS_OUTPUT.PUT_LINE(V_FNAME);
    END;
/


-----CONSTANTS IN PLSQL.
--- WE SHOULD DEFINE CONSTANTS UNDER "DECLARE" ONLY.
SET SERVEROUTPUT ON;

DECLARE
V_PI CONSTANT NUMBER(7,6) := 3.141592;
BEGIN
DBMS_OUTPUT.PUT_LINE(V_PI);
END;


--USE OF DEFAULT IN CONSTANTS.
SET SERVEROUTPUT ON;

DECLARE
V_PI CONSTANT NUMBER(7,6) DEFAULT 3.141592;
BEGIN
DBMS_OUTPUT.PUT_LINE(V_PI);
END;



--USE OF NOT NULL IN CONSTANTS.
---NOT NULL PREVENT ENTRY OF NULL VALUES.
SET SERVEROUTPUT ON;

DECLARE
V_PI CONSTANT NUMBER(7,6) NOT NULL DEFAULT 3.141592;
BEGIN
DBMS_OUTPUT.PUT_LINE(V_PI);
END;


----BIND VARIABLES OR HOST VARIABLES.
---BIND VARIABLES IN ORACLE DATABASE CAN BE DEFINED AS THE VARIABLES THAT WE CREATE IN SQL PLUS AND THEN REFERENCE IN PL/SQL.

---INITIALIZING  BIND VARIABLE.
SET SERVEROUTPUT ON;
VARIABLE V_BIND1 VARCHAR2(10);
EXECUTE : V_BIND1 := 'CHETHAN';
PRINT : V_BIND1;

---OR
SET SERVEROUTPUT ON;
VARIABLE V_BIND1 VARCHAR2(30);
BEGIN
:V_BIND1 := 'RAMESH IS GOOD BOY ';
DBMS_OUTPUT.PUT_LINE(:V_BIND1);  ---THIS WORKS ONLY INSIDE EXECUTABLE STATEMENT ONLY.
END;
/

---OR 

SET AUTOPRINT ON;
VARIABLE V_BIND1 VARCHAR2(10);
EXECUTE : V_BIND1 := 'CHETHAN';


----CONDITIONAL STATEMENTS.
---IF-THEN ELSE CONDITIONAL STATEMENTS.
SET SERVEROUTPUT ON;
DECLARE
V_NUM NUMBER := &ENTER_A_NUMBER;
BEGIN
 IF MOD(V_NUM,2)=0 THEN
 DBMS_OUTPUT.PUT_LINE(V_NUM||' IS EVEN');
 ELSE
 DBMS_OUTPUT.PUT_LINE(V_NUM||' IS ODD');
 END IF;
 DBMS_OUTPUT.PUT_LINE('YOUR IF-THEN ELSE STATEMENTS COMPLETED ');
END;


---IF-THEN - ELSIF-THAN ELSE CONDITIONAL STATEMENTS.
SET SERVEROUTPUT ON;
DECLARE
V_NUM NUMBER := &GUESS_A_NUMBER;
BEGIN
  DBMS_OUTPUT.PUT_LINE('ENTER THE NUMBER:'||V_NUM );
 IF V_NUM = 10 THEN
 DBMS_OUTPUT.PUT_LINE('YOU ENTERED CORRECT NUMBER');
 ELSIF V_NUM > 10 THEN
 DBMS_OUTPUT.PUT_LINE('YOU ENTERED GRATER NUMBER');
 ELSIF V_NUM < 10 THEN
 DBMS_OUTPUT.PUT_LINE('YOU ENTERED LESSER NUMBER');
 ELSE
 DBMS_OUTPUT.PUT_LINE('ENTER CORRECT NUMBERS');
 END IF;
 DBMS_OUTPUT.PUT_LINE('THANK YOU FOR PLAYING');
END;


---SIMPLE LOOP.
---MULTIPLICATION TABLE USING LOOP.
SET SERVEROUTPUT ON;
DECLARE
    V_COUNTER NUMBER := 0;
    V_RESULT NUMBER;
    V_INPUT NUMBER := &ENTER_INPUT;
BEGIN
 LOOP 
    V_COUNTER := V_COUNTER +1;
    V_RESULT := V_INPUT * V_COUNTER;
     DBMS_OUTPUT.PUT_LINE(V_INPUT || ' X ' || V_COUNTER || ' = ' || V_RESULT);
EXIT WHEN V_COUNTER >=10;
END LOOP;
END;

--OR USING "IF" INSTED OF "WHEN" IN EXIT CONDITION.
SET SERVEROUTPUT ON;
DECLARE
    V_COUNTER NUMBER := 0;
    V_RESULT NUMBER;
    V_INPUT NUMBER := &ENTER_INPUT;
BEGIN
 LOOP 
    V_COUNTER := V_COUNTER +1;
    V_RESULT := V_INPUT * V_COUNTER;
     DBMS_OUTPUT.PUT_LINE(V_INPUT || ' X ' || V_COUNTER || ' = ' || V_RESULT);
IF V_COUNTER >=10 THEN
EXIT;
END IF;
END LOOP;
END;



---WHILE LOOP IN PLSQL.
---EXAMPLE:1.
SET SERVEROUTPUT ON;
DECLARE
    V_COUNTER NUMBER := 1;
    V_RESULT NUMBER;
    V_INPUT NUMBER := &ENTER_INPUT;
BEGIN
 WHILE V_COUNTER <=10
 LOOP
    
    V_RESULT := V_INPUT * V_COUNTER;
    DBMS_OUTPUT.PUT_LINE(V_INPUT || ' X ' || V_COUNTER || ' = ' || V_RESULT);
    V_COUNTER := V_COUNTER +1;
END LOOP;
END;


---EXAMPLE:2.
SET SERVEROUTPUT ON;
DECLARE
V_TEST BOOLEAN := TRUE;
V_COUNT NUMBER :=0;
BEGIN
 WHILE V_TEST 
 LOOP
    V_COUNT := V_COUNT +1;
    DBMS_OUTPUT.PUT_LINE(V_COUNT);
    
    -- LOOP TERMINATION CODE.
    IF V_COUNT =10 THEN
    V_TEST := FALSE;
    END IF;
END LOOP;
END;
/



---FOR LOOP
--THERE ARE TWO TYPE 1.NUMERIC FOR LOOP AND 2.CURSOR FOR LOOP.
---1.0 NUMERIC FOR LOOP.
SET SERVEROUTPUT ON;
BEGIN
FOR V_COUNT IN 1 .. 10 LOOP
DBMS_OUTPUT.PUT_LINE(V_COUNT);
END LOOP;
END;


---USING 'REVERSE' IN FOR LOOP.
SET SERVEROUTPUT ON;
BEGIN
FOR V_COUNT IN REVERSE 1 .. 10 LOOP
DBMS_OUTPUT.PUT_LINE(V_COUNT);
END LOOP;
END;

---MULTIPLCATION TABLE BY FOR LOOP.
DECLARE
V_RESULT NUMBER;
V_INPUT NUMBER := &ENTER_INPUT;
BEGIN
FOR V_COUNTER IN 1..10 LOOP
V_RESULT :=V_INPUT*V_COUNTER;
DBMS_OUTPUT.PUT_LINE(V_INPUT || ' X '||V_COUNTER||' = '|| V_RESULT);
END LOOP;
END;


---TRIGGERS IN PL/SQL.
/* TRIGGERS ARE NAMED PL/SQL BLOCKS WHICH ARE STORED IN THE DATABASE OR SPECIALIZED STORED PROGRAMS WHICH EXCUTE IMPLICITLY WHEN A TRIGGERING EVENT OCCURS*/
/* TYPES: 1.DML TRIGGERS. 2.DDL TRIGGERS. 3.SYSTEM/DATABASE TRIGGERS. 4.INSTED OF TRIGGER. 5.COMPOUND TRIGGERS.*/ 
/* USES OF TRIGGERS
   1. ENFORCE BUSINESS RULES.
   2. GAIN STRONG CONTROL OVER THE SECURITY.
   3. COLLECT STATISTICAL INFORMATION.
   4. AUTOMATICALLY GENERATE VALUES.
   5. PREVENT INVALID TRANSACTIONS. */

--- DMAL TRIGGERS FOR INSERT.
CREATE TABLE SUPERHEROS
( SH_NAME VARCHAR2(20)
);

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER BI_SUPERHEROS
BEFORE INSERT ON SUPERHEROS
FOR EACH ROW
ENABLE
DECLARE
    V_USER VARCHAR2(20);
BEGIN
 SELECT USER INTO V_USER FROM DUAL;
 DBMS_OUTPUT.PUT_LINE('YOU JUST INSERTED A LINE MR. '||V_USER);
 END;
 /

INSERT INTO SUPERHEROS VALUES('SUPER MAN');
INSERT INTO SUPERHEROS VALUES('IRON MAN');



--- DMAL TRIGGERS FOR UPDATE.
SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER BU_SUPERHEROS
BEFORE UPDATE ON SUPERHEROS
FOR EACH ROW
ENABLE
DECLARE
    V_USER VARCHAR2(20);
BEGIN
 SELECT USER INTO V_USER FROM DUAL;
 DBMS_OUTPUT.PUT_LINE('YOU JUST UPDATED A LINE MR. '||V_USER);
 END;
 /


UPDATE SUPERHEROS
SET SH_NAME = 'BATMANT'
WHERE SH_NAME = 'SUPER MAN';



--- DMAL TRIGGERS FOR DELETE.
SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER BD_SUPERHEROS
BEFORE DELETE ON SUPERHEROS
FOR EACH ROW
ENABLE
DECLARE
    V_USER VARCHAR2(20);
BEGIN
 SELECT USER INTO V_USER FROM DUAL;
 DBMS_OUTPUT.PUT_LINE('YOU JUST DELETED A LINE MR. '||V_USER);
 END;
 /


DELETE SUPERHEROS
WHERE SH_NAME = 'IRON MAN';


---ALL DML OPERATIONS IN ONE TRIGGER.
CREATE TABLE HEROS1
( SH_NAME VARCHAR2(20)
);


SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER TR_SUPERHEROS
BEFORE INSERT OR DELETE OR UPDATE ON HEROS1
FOR EACH ROW
ENABLE
DECLARE
    V_USER VARCHAR2(20);
BEGIN 
    SELECT USER INTO V_USER FROM DUAL;
    IF INSERTING THEN
    DBMS_OUTPUT.PUT_LINE('YOU JUST INSERTED A LINE MR. '||V_USER);
    ELSIF DELETING THEN
    DBMS_OUTPUT.PUT_LINE('YOU JUST DELETED A LINE MR. '||V_USER);
    ELSIF UPDATING THEN
    DBMS_OUTPUT.PUT_LINE('YOU JUST UPDATED A LINE MR. '||V_USER);
    END IF;
END;
/


INSERT INTO HEROS1 VALUES('BAT MAN');
INSERT INTO HEROS1 VALUES('SUPER MAN');

UPDATE HEROS1
SET SH_NAME = 'IRON MAN'
WHERE SH_NAME = 'BAT MAN';


DELETE HEROS1
WHERE SH_NAME = 'SUPER MAN';




----TABLE AUDITING USING DML TRIGGER.
CREATE TABLE SUPERHEROS
( SH_NAME VARCHAR2(20)
);


CREATE TABLE SH_AUDIT
( NEW_NAME VARCHAR2(20),
  OLD_NAME VARCHAR2(20),
  USER_NAME VARCHAR2(20),
  ENTRY_DATE VARCHAR2(25),
  OPERATION VARCHAR2(20));


SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER SUPERHEROS_AUDIT
BEFORE INSERT OR DELETE OR UPDATE ON SUPERHEROS
FOR EACH ROW
ENABLE
DECLARE
    V_USER VARCHAR2(20);
    V_DATE VARCHAR2(30);
BEGIN 
SELECT USER, TO_CHAR(SYSDATE,'DD/MON/YYY HH24:MI:SS') INTO V_USER, V_DATE FROM DUAL;
IF INSERTING THEN
    INSERT INTO SH_AUDIT(NEW_NAME, OLD_NAME, USER_NAME, ENTRY_DATE, OPERATION)
    VALUES (:NEW.SH_NAME, NULL, V_USER, V_DATE,'INSERT');
ELSIF DELETING THEN
     INSERT INTO SH_AUDIT (NEW_NAME, OLD_NAME, USER_NAME, ENTRY_DATE, OPERATION)
     VALUES(NULL,:OLD.SH_NAME, V_USER, V_DATE,'DELETE');
ELSIF UPDATING THEN
     INSERT INTO SH_AUDIT (NEW_NAME, OLD_NAME, USER_NAME, ENTRY_DATE, OPERATION)
     VALUES(:NEW.SH_NAME,:OLD.SH_NAME, V_USER, V_DATE,'UPDATE');
END IF;
END;
/


SELECT * FROM SH_AUDIT;
INSERT INTO SUPERHEROS VALUES('SUPER MAN');
INSERT INTO SUPERHEROS VALUES('BAT MAN');
INSERT INTO SUPERHEROS VALUES('SPIDER MAN');

UPDATE SUPERHEROS
SET SH_NAME = 'BATMANT'
WHERE SH_NAME = 'SUPER MAN';

DELETE SUPERHEROS
WHERE SH_NAME = 'BAT MAN';


SELECT * FROM SH_AUDIT;


--- MAKE A SYNCHRINIZED BACKUP COPY OF TABLE USING DML TRIGGER.
--- THIS TRIGGER WILL INSERT, UPDATE  AND DELETE OPERATION IN BOTH PRESENT TABLE AND BACKUP TABLEN ALSO AND STORE DATA.
DESC SUPERHEROS;

CREATE TABLE  SUPERHEROS_BACKUP AS SELECT * FROM SUPERHEROS WHERE 1=2;

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER SH_BACKUP
BEFORE INSERT OR DELETE OR UPDATE ON SUPERHEROS
FOR EACH ROW
ENABLE
BEGIN
    IF INSERTING THEN
     INSERT INTO SUPERHEROS_BACKUP (SH_NAME) VALUES(:NEW.SH_NAME);
    ELSIF DELETING THEN
     DELETE FROM SUPERHEROS_BACKUP WHERE SH_NAME = :OLD.SH_NAME;
    ELSIF UPDATING THEN
     UPDATE SUPERHEROS_BACKUP SET SH_NAME = :NEW.SH_NAME WHERE SH_NAME = :OLD.SH_NAME;
    END IF;
END;
/

TRUNCATE TABLE SUPERHEROS;
SELECT * FROM SUPERHEROS;
SELECT * FROM SUPERHEROS_BACKUP;


INSERT INTO SUPERHEROS VALUES('SUPER MAN');
INSERT INTO SUPERHEROS VALUES('BAT MAN');
INSERT INTO SUPERHEROS VALUES('SPIDER MAN');

UPDATE SUPERHEROS
SET SH_NAME = 'IRON MAN'
WHERE SH_NAME = 'SUPER MAN';


DELETE SUPERHEROS
WHERE SH_NAME = 'BAT MAN';



---DDL TRIGGER WITH SCHEMA AUDITING.
/* USING DDL TRIGGERS YOU CAN TRACK CHANGES TO THE DATABASE. */
SHOW USER;

CREATE TABLE SCHEMA_AUDIT
( DDL_DATE DATE,
 DDL_USER VARCHAR2(25),
 OBJECT_CREATED VARCHAR2(25),
 OBJECT_NAME VARCHAR2(25),
 DDL_OPERATION VARCHAR2(25) );


CREATE OR REPLACE TRIGGER HR_AUDIT_TR
AFTER DDL ON SCHEMA   --- HERE WE CAN USE LIKE FOR "ALTER" (AFTER ALTER ON SCHEMA), FOR "TRUNCATE" (AFTER TRUNCATE ON SCHEMA) AND FOR  COMBINED EVENTS LIKE "TRUNCATE" AND "CREATE" (AFTER TRUNCATE OR CREATE ON SCHEMA)
BEGIN
    INSERT INTO SCHEMA_AUDIT VALUES(
    SYSDATE,
    SYS_CONTEXT('USERENV','CURRENT_USER'),
    ORA_DICT_OBJ_TYPE,
    ORA_DICT_OBJ_NAME,
    ORA_SYSEVENT
    );
END;
/


SELECT * FROM SCHEMA_AUDIT;  --- THIS TABLE RECORDS ALL THE DDL OPERATIONS WHICH ARE PERFORMED BELOW.

CREATE TABLE DUMMYTABLE
( ROLLNO NUMBER(25)
);

TRUNCATE TABLE DUMMYTABLE;

ALTER TABLE DUMMYTABLE
MODIFY ROLLNO NUMBER(20);

DROP TABLE DUMMYTABLE;



----- HOW TO CREATE DATABASE EVENT TRIGGER "LOGON".
/* DATA BASE EVENT TRIGGERS COME INTO ACTION WHEN SOME SYSTEM EVENT OCCURS SUCH AS 
    1. DATABASE LOG ON.
    2. DATA BASE LOG OFF.
    3. START UP.
    4. SHUT DOWN. 
-- DATABASE EVENT TRIGGERS CAN BE CREATED TO MONITOR THE SYSTEM EVENT ACTIVITIES OF EITHER A SPECIFIC.
    1. USER OR A WHOLE DATABASE.
--- ANY USER OF YOUR DATABASE CAN CREATE A DATABASE EVENT TRIGGER IN IT'S OWN SCHEMA IF IT HAS CREATE TRIGGER SYSTEM PRIVILEGE.
--- TO CREATE TRIGGER ON THE DATABASE YOU MUST NEED ADMINISTRATIVE DATABASE TRRIGGER SYSTEM PRIVILEGES.*/

--- THIS IS FOR USER LEVEL AUDIT TRIGGER.
CREATE TABLE CHETU_EVNT_AUDIT
( EVENT_TYPE VARCHAR2(25),
  LOGON_DATE DATE,
  LOGON_TIME VARCHAR2(25),
  LOGOFF_DATE DATE,
  LOGOFF_TIME VARCHAR2(25)
  );

CREATE OR REPLACE TRIGGER CHETU_LOGON_AUDIT
AFTER LOGON ON SCHEMA
BEGIN
    INSERT INTO CHETU_EVNT_AUDIT VALUES(
    ORA_SYSEVENT,
    SYSDATE,
    TO_CHAR(SYSDATE,'HH24:MI:SS'),
    NULL,
    NULL
   );
    COMMIT;
END;
/


CREATE OR REPLACE TRIGGER CHETU_LOGOFF_AUDIT
BEFORE LOGOFF ON SCHEMA
BEGIN
    INSERT INTO CHETU_EVNT_AUDIT VALUES(
    ORA_SYSEVENT,
    NULL,
    NULL,
    SYSDATE,
    TO_CHAR(SYSDATE,'HH24:MI:SS')
    );
    COMMIT;
END;
/



SELECT * FROM CHETU_EVNT_AUDIT;
DISC;

CONN chetu/chetu;



--- FOR DATABASE LEVEL AUDIT TRIGGER.
--- IT AUDITS LOGON AND LOGOFF OF ALL USER AND SCHEMA DETAILS.
--- BEFORE CREATING LOGON TO SYSTEM DATABASE( THIS IS ADMIN DATA BASE).

CREATE TABLE DB_EVNT_AUDIT
( USER_NAME VARCHAR2(25),
  EVENT_TYPE VARCHAR2(25),
  LOGON_DATE DATE,
  LOGON_TIME VARCHAR2(25),
  LOGOFF_DATE DATE,
  LOGOFF_TIME VARCHAR2(25)
  );
  
CREATE OR REPLACE TRIGGER DB_LOGON_AUDIT
AFTER LOGON ON DATABASE
BEGIN
    INSERT INTO DB_EVNT_AUDIT VALUES(
    USER,
    ORA_SYSEVENT,
    SYSDATE,
    TO_CHAR(SYSDATE,'HH24:MI:SS'),
    NULL,
    NULL
     );
    COMMIT;
END;
/



CREATE OR REPLACE TRIGGER DB_LOGOFF_AUDIT
BEFORE LOGOFF ON DATABASE
BEGIN
    INSERT INTO DB_EVNT_AUDIT VALUES(
    USER,
    ORA_SYSEVENT,
    NULL,
    NULL,
    SYSDATE,
    TO_CHAR(SYSDATE,'HH24:MI:SS')
    );
    COMMIT;
END;
/

SELECT * FROM DB_EVNT_AUDIT;

/*select count(EVENT_TYPE) from DB_EVNT_AUDIT
where EVENT_TYPE ='LOGON' AND USER_NAME= 'HR';

select (sysdate-min(LOGON_DATE)) from DB_EVNT_AUDIT;*/




--- HOW TO CREATE STARTUP TRIGGERS.
--- THIS WILL TRIGGER WHEN EVER DATABASE STARTS UP.
--- BEFORE CREATING LOGON TO SYSTEM DATABASE( THIS IS ADMIN DATA BASE)

CREATE TABLE STARTUP_AUDIT
(EVENT_TYPE VARCHAR2(25),
  EVENT_DATE DATE,
  EVENT_TIME VARCHAR2(25)
  );


CREATE OR REPLACE TRIGGER TR_STARTUP_AUDIT
AFTER STARTUP ON DATABASE
BEGIN 
 INSERT INTO STARTUP_AUDIT VALUES(
  ORA_SYSEVENT,
  SYSDATE,
  TO_CHAR(SYSDATE,'HH24:MI:SS')
  );
END;
/


SELECT * FROM STARTUP_AUDIT;



---- INSTEAD OF TRIGGER.
/* USING INSTEAD OF TRIGGER WE CAN CONTROLL THE DEFAULT BEHAVIOUR OF INSERT, UPDATE, DELETE AND MERGE OPERATION ON "VIEWS" BUT NOT ON "TABLES"
  1. WE CAN USE THEM TO MAKE A NON-UPDATABLE VIEW UPDATABLE.
  2. OVERRIDE THE DEFAULT BEHAVIOUR OF VIEW THAT ARE UPDATABLE.*/


--- 1. INSTEAD OF INSERT TRIGGER
CREATE TABLE TRAINER
(
FULL_NAME VARCHAR2(25)
);


CREATE TABLE SUBJECT
(
SUBLECT_NAME VARCHAR2(25)  --- CHECK SPELLING HERE "SUBLECT" NOT "SUBJECT".
);


INSERT INTO TRAINER VALUES('RAMESH');
INSERT INTO SUBJECT VALUES('ORACLE');

CREATE VIEW VW_INSTEDTRIGGER AS
SELECT FULL_NAME, SUBLECT_NAME FROM TRAINER, SUBJECT;

SELECT * FROM VW_INSTEDTRIGGER;
--THIS VIEW IS JOIN OF TWO TABLE WE CAN NOT ADD RECORD TO IT BY NORMAL INSERT, BUT BY USING INSTEAD OF TRIGGER IT IS POSSIBLE TO INSERT RECORD.

CREATE OR REPLACE TRIGGER TR_IO_INSERT
INSTEAD OF INSERT ON VW_INSTEDTRIGGER
FOR EACH ROW
BEGIN
 INSERT INTO TRAINER (FULL_NAME) VALUES(:NEW.FULL_NAME);
 INSERT INTO SUBJECT (SUBLECT_NAME) VALUES(:NEW.SUBLECT_NAME);
END;
/

INSERT INTO VW_INSTEDTRIGGER VALUES( 'MANISH','JAVA');
SELECT * FROM VW_INSTEDTRIGGER;



---2. INSTEAD OF UPDATE TRIGGER.
DESC VW_INSTEDTRIGGER;

CREATE OR REPLACE TRIGGER TR_IO_UPDATE
INSTEAD OF UPDATE ON VW_INSTEDTRIGGER
FOR EACH ROW
BEGIN
   UPDATE TRAINER SET  FULL_NAME = :NEW.FULL_NAME
   WHERE FULL_NAME = :OLD.FULL_NAME;
   
   UPDATE SUBJECT SET  SUBLECT_NAME = :NEW.SUBLECT_NAME
   WHERE SUBLECT_NAME = :OLD.SUBLECT_NAME;
   
END;
/

UPDATE VW_INSTEDTRIGGER
SET FULL_NAME ='TONY STARK'
WHERE SUBLECT_NAME = 'JAVA';

SELECT * FROM VW_INSTEDTRIGGER;


------3. INSTEAD OF DELETE TRIGGER.
/* IN CASE OF A COMPLEX VIEW WHICH YOU HAVE CREATED ON MULTIPLE TABLES, IT IS ADVISABLE TO USE INSTED OF TRIGGER SO AS TO SUPPORT THE INSERT, DELETES
AND UPDATES THAT REFERENCE THE DATA IN MULTIPLE TABLES.*/.
DESC VW_INSTEDTRIGGER;

CREATE OR REPLACE TRIGGER TR_IO_DELETE
INSTEAD OF DELETE ON VW_INSTEDTRIGGER
FOR EACH ROW
BEGIN
   DELETE FROM TRAINER WHERE FULL_NAME = :OLD.FULL_NAME;
   DELETE FROM SUBJECT WHERE SUBLECT_NAME =:OLD.SUBLECT_NAME;
   
END;
/

DELETE FROM VW_INSTEDTRIGGER WHERE FULL_NAME = 'TONY STARK';

SELECT * FROM VW_INSTEDTRIGGER;



----CURSORS IN ORACLE DATABASE.
/*CURSOR IS A POINTOR TO A MEMORY AREA CALLED CONTEXT AREA. CONTEST AREA IS A MEMORY REGION INSIDE THE PROCESS GLOBAL AREA OR PGA. ASSIGNED TO HOLD THE INFORMATION ABOUT THE
PROCESSING OF A SELECT STATEMENT OR DML STATEMENT
--- CONTEST AREA : IT IS A MEMORY REGION INSIDE THE PGA WHICH ORACLE SERVER IN PROCESSING AN SQL STATEMENT BY HOLDING THE IMPORTANT INFORMATION ABOUT THE STATEMENT.*/
SET SERVEROUTPUT ON;
DECLARE
 V_NAME VARCHAR2(25);
 CURSOR CUR_CHETHAN IS 
 SELECT FIRST_NAME FROM EMPLOYEES
 WHERE EMPLOYEE_ID<105;
BEGIN
 OPEN CUR_CHETHAN;
 LOOP
     FETCH CUR_CHETHAN INTO V_NAME;
     DBMS_OUTPUT.PUT_LINE(V_NAME);
     EXIT WHEN CUR_CHETHAN%NOTFOUND;
 END LOOP;
 CLOSE CUR_CHETHAN;
END;
/


---CURSOR PARAMETER.
SET SERVEROUTPUT ON;
DECLARE
 V_NAME VARCHAR2(25);
 CURSOR P_CUR_CHETHAN(VAR_E_ID VARCHAR2) IS 
 SELECT FIRST_NAME FROM EMPLOYEES
 WHERE EMPLOYEE_ID<VAR_E_ID;
BEGIN
 OPEN P_CUR_CHETHAN(105);
 LOOP
     FETCH P_CUR_CHETHAN INTO V_NAME;
     DBMS_OUTPUT.PUT_LINE(V_NAME);
     EXIT WHEN P_CUR_CHETHAN%NOTFOUND;
 END LOOP;
 CLOSE P_CUR_CHETHAN;
END;
/



--- HOW TO CREATE CURSOR PARAMETER WITH DEFAULT VALUE.
SET SERVEROUTPUT ON;
DECLARE
 V_NAME VARCHAR2(25);
 V_EID NUMBER(10);
 CURSOR PP_CUR_CHETHAN(VAR_E_ID NUMBER := 109) IS 
 SELECT FIRST_NAME,EMPLOYEE_ID FROM EMPLOYEES
 WHERE EMPLOYEE_ID>VAR_E_ID;
BEGIN
 OPEN PP_CUR_CHETHAN;  --IF WE SPECIFY PARAMETER VALUE (OPEN PP_CUR_CHETHAN(115)) HERE, ORACLE WILL OVER WRITE DEFAULT VALUE "109" AND TAKE PARAMETER VALUE "115".
 LOOP
     FETCH PP_CUR_CHETHAN INTO V_NAME,V_EID;
     DBMS_OUTPUT.PUT_LINE(V_NAME||' '||V_EID);
     EXIT WHEN PP_CUR_CHETHAN%NOTFOUND;
 END LOOP;
 CLOSE PP_CUR_CHETHAN;
END;
/


--- CURSOR FOR LOOP.
SET SERVEROUTPUT ON;
DECLARE
 CURSOR PPP_CUR_CHETHAN IS 
 SELECT FIRST_NAME,EMPLOYEE_ID FROM EMPLOYEES
 WHERE EMPLOYEE_ID> 200;
BEGIN
    FOR L_IDX IN PPP_CUR_CHETHAN
    LOOP
         DBMS_OUTPUT.PUT_LINE(L_IDX.FIRST_NAME||' '||L_IDX.EMPLOYEE_ID);
    END LOOP;
END;
/
     

--- CURSOR FOR LOOP WITH PARAMETERIZED CURSOR.
SET SERVEROUTPUT ON;
DECLARE
 CURSOR PPP_CUR_CHETHAN (V_E_ID NUMBER) IS 
 SELECT FIRST_NAME,EMPLOYEE_ID FROM EMPLOYEES
 WHERE EMPLOYEE_ID> V_E_ID;
BEGIN
    FOR L_IDX IN PPP_CUR_CHETHAN(200)
    LOOP
         DBMS_OUTPUT.PUT_LINE(L_IDX.FIRST_NAME||' '||L_IDX.EMPLOYEE_ID);
    END LOOP;
END;
/
   
---INTRODUCTION TO PL/SQL RECORD DATATYPE.
-- A RECORD IS A GROUP OF RELATED DATA ITEMS STORED IN FIELDS, EACH WITH IT'S OWN NAME AND DATATYPE.
-- TYPES 1. TABLE BASE RECORD. 2.CURSOR BASED RECORD. 3.USER DEFINED RECORD.
-- "%ROWTYPE" IS USED TO DECLARE RECORD.









































