
---"ANALYTICAL FUNCTION"
--SYNTAX 
/*ANALYTICAL FUNCTION(COL1,COL2...) MIN(SALARY)
OVER ( 
(PARTITION BY CLAUSE)
(ORDER BY CLAUSE)
(WINDOWING CLAUSE)
);*/


---1. FINDING AVG,SUM,MIN ect. OF SALARY BY USING ANALYTICAL FUNCTION.

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, MANAGER_ID, DEPARTMENT_ID,
TRUNC(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID)) AVG_SAL,SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) SUM_SAL
FROM EMPLOYEES;

---2. FIND THE DETAILS OF MOST RECENT JOINEE FROM ALL DEPARTMENT.
SELECT FIRST_NAME FROM (
                SELECT E.*,LEAD(HIRE_DATE) OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE) RECENT_JOINEE
                FROM EMPLOYEES E)
WHERE RECENT_JOINEE IS NULL;

--STEP:1
SELECT E.*,LEAD(HIRE_DATE) OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE) RECENT_JOINEE
FROM EMPLOYEES E; ---NULL PRESENT IN RECENT_JOINEE COLUMN REPRESENT WHO EVER IS JOINED RECENTLY IN A PARTICULAR DEPARTMENT BECAUSE RECENT_JOINEE COLUMN IS ORDERED BY HIRE_DATE.
            
--STEP:2
SELECT * FROM (
                SELECT E.*,LEAD(HIRE_DATE) OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE ASC,FIRST_NAME DESC) RECENT_JOINEE
                FROM EMPLOYEES E)
WHERE RECENT_JOINEE IS NULL;

----OR IN DEPARTMENT 80 AND 110 TWO EMPLOYEES HAVING SAME DATE OF BIRTH. TO SELECT ONE RECORD WE NEED TO ORDER BY FIRST_NAME ALSO.
SELECT * FROM (
SELECT E.*, RANK() OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE DESC,FIRST_NAME) RANK
FROM EMPLOYEES E)
WHERE RANK=1;




----3. CUMMELATIVE SALARY DEPARTMENTWISE.
SELECT E.*,SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID ORDER BY EMPLOYEE_ID) CUMM_SUM
FROM EMPLOYEES E
ORDER BY EMPLOYEE_ID,DEPARTMENT_ID;

---CUMMELATIVE SALARY OF OVERALL ORGANISATION.
SELECT E.*,SUM(SALARY) OVER( ORDER BY EMPLOYEE_ID) CUMM_SUM
FROM EMPLOYEES E
ORDER BY EMPLOYEE_ID,DEPARTMENT_ID; ---HERE WE GET CUMMELATIVE SALARY AT THE LAST ROW OF TABLE.
--OR
SELECT E.*,SUM(SALARY) OVER( ) CUMM_SUM
FROM EMPLOYEES E
ORDER BY EMPLOYEE_ID,DEPARTMENT_ID;---HERE WE GET AT THE EVERY ROW.


----4."WINDOWING FUNCTION"
--FIND THE AVERAGE OF SALARY OF PREVIOUS 2 EMPLOYEES
SELECT E.*, TRUNC(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE ROWS 2 PRECEDING)) AVG_SAL 
FROM EMPLOYEES E
ORDER BY EMPLOYEE_ID,DEPARTMENT_ID;

----5. a). SELECT THE DETAILS OF EMPLOYEES WITH MINIMUM SALARY ON THEIR DESIGNATION.
--b). SELECT OLDEST EMPLOYEES FROM EACH DEPARTMENT, ADD AN ADDITIONAL COLUMN AND GIVE THEM A 10% BONUS.
--c). DISPLAY ALL THE EMPLOYEE DETAILS ALONG WITH THE COUNT OF REPORTEES THEIR MANAGER HAS.
--d). DETAILS OF ALL EMPLOYEES ALONG WITH AN ADDITIONAL COLUMN WHICH SHOWS AVERAGE OF SALARY PARTITIONED BY DESIGNATION BUT ONLY FOR EMPLOYEES THAT WERE HEIRED BEFORE 12 YEARS.

--a). SELECT THE DETAILS OF EMPLOYEES WITH MINIMUM SALARY ON THEIR DESIGNATION.
SELECT * FROM EMPLOYEES E1,(
            SELECT JOB_ID,MIN(SALARY) MIN_SAL
            FROM EMPLOYEES 
            GROUP BY JOB_ID) E
WHERE E1.JOB_ID=E.JOB_ID
AND E1.SALARY=E.MIN_SAL;
---OR

SELECT * FROM (
                SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID,
                MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY) AVG_SAL
                FROM EMPLOYEES )
WHERE SALARY =   AVG_SAL;              ;


--b). SELECT OLDEST EMPLOYEES FROM EACH DEPARTMENT, ADD AN ADDITIONAL COLUMN AND GIVE THEM A 10% BONUS.

SELECT * FROM (
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY,(SALARY + SALARY*0.1) BONUS, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID,
                 MIN(HIRE_DATE) OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE) OLDEST
                 FROM EMPLOYEES)
                 WHERE HIRE_DATE =  OLDEST ;

--c). DISPLAY ALL THE EMPLOYEE DETAILS ALONG WITH THE COUNT OF REPORTEES THEIR MANAGER HAS.
SELECT * FROM EMPLOYEES A,           
           ( SELECT MANAGER_ID,COUNT(*)
            FROM EMPLOYEES
            GROUP BY MANAGER_ID) B
WHERE A.MANAGER_ID=B.MANAGER_ID
ORDER BY A.EMPLOYEE_ID;

 ---OR
 
 SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID,
 COUNT(*) OVER(PARTITION BY MANAGER_ID) COUNTS
 FROM EMPLOYEES
 ORDER BY EMPLOYEE_ID;
 
--d). DETAILS OF ALL EMPLOYEES ALONG WITH AN ADDITIONAL COLUMN WHICH SHOWS AVERAGE OF SALARY PARTITIONED BY DESIGNATION BUT ONLY FOR EMPLOYEES THAT WERE HEIRED BEFORE 12 YEARS.


----USAGE OF ORACLE METADATA TO OUR ADVANTAGE.
----a).TO FIND LAST CHANGED DATE TIME(LAST_DDL_TIME),OBJECT_TYPE,CREATED DATE etc.
---IF SOMONE ACCUSE US LIKE FILURE IS FROM YOUR SIDE TO OVER COME WE CAN SEE WHO CHANGED AND WHEN CHANGED IN THIS TABLE.
SELECT * FROM ALL_OBJECTS
WHERE OWNER = 'CHETU'
ORDER BY LAST_DDL_TIME DESC;

----b).IF REQUIREMENT IS TO VERIFY COLUMN NAME "WINNER" BUT WE DONT NO IN WHICH TABLE IT IS PRESENT. THIS QUERY RETURNS TABLE NAME AND OTHER DETAILS.
SELECT * FROM ALL_TAB_COLS
WHERE OWNER = 'CHETU' AND COLUMN_NAME= 'WINNER';

SELECT * FROM CRICKET;

----c). IT GIVES ALL DETAILS OF IMPACT TO TABLE LIKE "TRIGGER", "PROCEDURE", "FUNCTION" etc.
SELECT * FROM ALL_SOURCE 
WHERE UPPER(TEXT) LIKE '%BSEIT1%' AND OWNER = 'CHETU';


----d).IT RETURNS "OBJECT_NAME" THAT ARE IN "INVALID" STATUS. FROM THIS WE CAN IDENTIFY WHAT IS THE REASON OF JOB FAILURE.
SELECT * FROM ALL_OBJECTS
WHERE OWNER = 'CHETU' AND STATUS = 'INVALID';


/*----e).HERE WE CAN SEE ONLY FEW TABLES ARE ANALYSED FREQUENTLY AND SOME OTHERS ARE NOT ANALYSED BY MORE THAN A YEARS WILL CAUSE PERFORMANCE 
ISSUE AND FREQUENT ANALYZE OF TABLES IMPROVES PERFORMANCE OF DATABASE*/
SELECT A.LAST_ANALYZED,A.* FROM ALL_TABLES A
WHERE OWNER = 'HR'
ORDER BY A.LAST_ANALYZED DESC;


/*----f).IT WILL RETURNS DETAILS LIKE "JOB_ID" IS NOT NULL,"HIRE_DATE" IS NOT NULL,"EMAIL" IS NOT NULL,"LAST_NAME" IS NOT NULL etc WIIL BE EASY TO
DEBUG WHILE TESTING TABLES */
SELECT * FROM ALL_CONSTRAINTS
WHERE OWNER = 'HR' AND TABLE_NAME='EMPLOYEES';




-----""VIEW" USAGE IN REALTIME PROJECT.
/*--"VIEWS" ARE CREATED TO GIVE ACCESS TO READ DATA FOR PEOPLE WHO ARE NOT PART OF ORGANISATION.  HERE ONLY REQUIRED DATA IN A TABLE IS SELECTED
AND CREATE TABLE FOR THEIR ACCESS. BY THIS WE CAN MAINTAIN SECURITY OF DATA BY NOT GIVING ACCESS TO VIEW FULL DATA IN A TABLE .
---IF WE INSERT,UPDATE AND DELETE(DML OPERATION) IN A VIEW, UNDERLYING TABLE ALSO INSERT,UPDATES AND DELETS DATA
---IF WE DROP UNDERLYING TABLE VIEW WILL NOT GOING TO  DROPED IF WE RUN QUERY IT SHOW ERROR. AS SOON AS WE RECREATE TABLE IT STARTS RUNNING FINE. */
CREATE VIEW EMPLOYEE_ITPROG AS SELECT * FROM EMPLOYEES WHERE JOB_ID='IT_PROG';

SELECT * FROM EMPLOYEE_ITPROG;

SELECT * FROM EMPLOYEES;


----TEST DATA GENERATION.
SELECT DBMS_RANDOM.VALUE(10,100) FROM DUAL;

SELECT FLOOR(DBMS_RANDOM.VALUE(10,100)) FROM DUAL;

SELECT DBMS_RANDOM.STRING('A',6) FROM DUAL;

SELECT FLOOR(DBMS_RANDOM.VALUE(10,100)) FROM DUAL
CONNECT BY LEVEL <=100;

CREATE TABLE TEST_DATA AS
SELECT ROWNUM AS ID,DBMS_RANDOM.STRING('A',6) AS NAME,'M' AS GENDER,DBMS_RANDOM.STRING('A',6)||'@GMAIL.COM' AS EMAIL,
FLOOR(DBMS_RANDOM.VALUE(10,100))*1000 SALARY,FLOOR(DBMS_RANDOM.VALUE(1000000000000,99999999999999)) AS AADHAR_NO  FROM DUAL
CONNECT BY LEVEL <=25000;
----IT IS NOT POSSIBLE TO GENERATE GENDER COLUMN SO WE HARD CODED IT.

UPDATE TEST_DATA
SET GENDER= 'F'
WHERE MOD(ID,2)=1;

DROP TABLE TEST_DATA;

SELECT * FROM TEST_DATA;



-----"PARTITIONING" OF DATA.
CREATE TABLE TRANS_DEMO
(
TRANS_ID INT,
TRANS_TYPE VARCHAR2(25),
AMOUNT INT,
TRANS_DATE DATE
);

CREATE UNIQUE INDEX IDX_TRANS_ID ON TRANS_DEMO(TRANS_ID);

SELECT * FROM TRANS_DEMO;

INSERT INTO TRANS_DEMO
SELECT ROWNUM,'CREDIT',
FLOOR(DBMS_RANDOM.VALUE(90,900)),
TRUNC(SYSDATE)-FLOOR(DBMS_RANDOM.VALUE(9,900))
FROM DUAL
CONNECT BY LEVEL<=1000000;

SELECT SEGMENT_NAME, BLOCKS, BYTES/1024/1024 AS MB FROM USER_SEGMENTS 
WHERE segment_name='TRANS_DEMO';

ANALYZE INDEX IDX_TRANS_ID VALIDATE STRUCTURE;

SELECT * FROM INDEX_STATS;













