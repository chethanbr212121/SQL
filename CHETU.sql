--- LOG ON AND LOG OFF.
CONN chetu/chetu;  -- TO LOG ON.

DISC;  --- TO LOG OFF.



---THIS IS USED TO SHOW ALL TABLES IN A DATABASE.

SELECT * FROM tab;


--- CREATE TABLE

CREATE TABLE CHETHAN
(
empid NUMBER(10) PRIMARY KEY,
empname VARCHAR2(35),
empdob DATE,
empsalary NUMBER(12),
empgender CHAR(1),
emplocation VARCHAR2(35)
);



CREATE TABLE TABLE32
(
EID NUMBER(25) PRIMARY KEY,
ENAME VARCHAR2(25) NOT NULL,
DOB DATE,
SALARY NUMBER(25,3),
MOB_NO INT CHECK(LENGTH(MOB_NO)=10),
MANGID NUMBER(20) REFERENCES TABLE32(EID),
DEPARTMENT_ID NUMBER(20),
FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE CASCADE
);


CREATE TABLE STUD_CONSTRAINTS1
(
REG_NO NUMBER,
ROLL_NO NUMBER,
DEPT VARCHAR2(10),
NAME VARCHAR2(10),
CONSTRAINTS U1 UNIQUE(REG_NO,DEPT),
CONSTRAINTS U2 PRIMARY KEY(DEPT)
);


CREATE TABLE CHECKCONSTRAINTS
(EMPNO NUMBER(25) PRIMARY KEY,
ENAME VARCHAR2(25) CHECK(ENAME IN ('A','B')),
SAL NUMBER(25) DEFAULT(200),
LOC VARCHAR2(25) NOT NULL);

INSERT INTO CHECKCONSTRAINTS VALUES(1,'A',2000,'BANGLORE');  --- ENAME IS TAKEN AS "A" OR "B" ONLY.
INSERT INTO CHECKCONSTRAINTS(EMPNO,ENAME,LOC) VALUES(3,'A','HUBLI');  --HERE SALARY IS TAKEN AS DEFAULT VALUE 200.

SELECT * FROM CHECKCONSTRAINTS;



----META DATA TABLES WILL HAVE ALL TABLE & COLUMN LEVEL DETAILS.
SELECT * FROM all_constraints WHERE OWNER='HR' AND table_name='EMPLOYEES';

SELECT * FROM all_cons_columns WHERE OWNER='HR' AND table_name='EMPLOYEES';

SELECT * FROM all_tables WHERE OWNER='HR'; 

SELECT * FROM all_tab_columns WHERE OWNER='HR' AND column_name='SALARY'; 



-----ADD AND DROP "PRIMARY KEY" AND "FOREIGN KEY" TO TABLE.
ALTER TABLE tab_demo_test
ADD FOREIGN KEY (dept_no) REFERENCES demo_dept(dept_no); 

ALTER TABLE STUD_CONSTRAINTS1
ADD PRIMARY KEY (reg_no); 

ALTER TABLE customer
DROP CONSTRAINT SYS_C009091;----"SYS_C009091" IS "CONSTRAINT_NAME".

--- INSERT DATA INTO TABLE.

INSERT INTO chethan VALUES(1,'CHET','25-03-2000',6000,'M','BNG');
--OR
INSERT INTO chethan VALUES(2,'CHARY',NULL,8000,'M',NULL);--NULL SHOULD NOT BE IN QUOTE.
--OR
INSERT INTO chethan(empid,empname,empsalary,empgender) VALUES(3,'CHARU',9000,'F');--HERE ONLY REQUIRED COLUMNS ARE ADDED.


--- INSERTG MULTIPLE DATA INTO TABLE.
SELECT * FROM  chethan;
DESC CHETHAN;

INSERT ALL
INTO chethan VALUES(1,'CHET','25-03-2000',6000,'M','BNG',600)
INTO chethan VALUES(2,'CHARY',NULL,8000,'M',NULL,800)
INTO chethan VALUES(3,'RAMU',NULL,9000,'M','MUM',900)
SELECT * FROM DUAL;

----INSERTING DATA INTO TABLE FROM OTHER TABLES.
INSERT INTO chethan1 SELECT * FROM chethan WHERE empid=2;



---RENAME AND MODIFY A COLUMN USING ALTER.
ALTER TABLE chethan
RENAME COLUMN emplocation TO EMPPLACE;

ALTER TABLE chethan
MODIFY  EMPPLACE VARCHAR2(32);

--- ADD,DROP AND UPDATE FROM ALTER.

ALTER TABLE chethan2 
RENAME TO chethan3;

ALTER TABLE chethan
ADD EMPDEPARTMENT VARCHAR2(30);----ADDING NEW COLUMN TO TABLE.

ALTER TABLE chethan
DROP COLUMN EMPDEPARTMENT;

ALTER TABLE chethan
ADD EMPPF NUMBER(10);

UPDATE chethan
SET emppf=empsalary*2/100;-- IT WILL UPDATE TO FULL TABLE.

UPDATE chethan
SET emppf=empsalary*3/100
WHERE EMPID=2;-- BY USING WHERE CLAUSE IT WILL UPDATE TO ONLY EMPID=2.

UPDATE chethan
SET empdob='15-05-2005',empplace='MUM'
WHERE EMPID=2;-- BY USING WHERE CLAUSE IT WILL UPDATE MULTIPLE COLUMN OF SINGLE ROW(EMPID=2) (IT IS NOT POSSIBLE TO UPDATE MULTIPLE ROWS).


---DUPLICATE A TABLE WITH RECORDS AND WITHOUT RECORDS.
CREATE TABLE chethan1 AS SELECT * FROM chethan;--IT WILL COPY BOTH TABLE STRUCTURE AND RECORDS.

CREATE TABLE chethan2 AS SELECT * FROM chethan
WHERE 1=2;--IT WILL COPY ONLY TABLE STRUCTURE NOT RECORDS. 


---DELETE,ROLLBACK AND TRUNCATE TABLE DATA.
DELETE FROM chethan;--IT WILL DELETE ALL THE DATA ONLY NOT TABLE STRUCTURE.

DELETE FROM chethan
WHERE EMPID=3;--IT WILL DELETE ONLY EMPID=3 RECORDS.

ROLLBACK;--IT WILL UNDO DELETED RECORDS.

TRUNCATE TABLE chethan;--ONCE WE TRUNCATE TABLE WE CANNOT ROLL BACK AGAIN.

---ADD COMMENT ON A TABLE AND COLUMN ALSO REMOVE COMMENT.

COMMENT ON TABLE chethan
IS 'Employee Information';--IT IS USED TO COMMENT ON TABLE.

SELECT * FROM USER_TAB_COMMENTS; -- IT WILL SHOWS COMMENT OF ALL THE TABLE.

SELECT * FROM USER_TAB_COMMENTS
WHERE TABLE_NAME = 'CHETHAN'; -- IT WILL SHOWS COMMENT OF SELECTED TABLE(TABLE NAME SHOULD BE IN CAPS OR SMALL LETTER AS IN TABLE).

COMMENT ON TABLE chethan
IS '';--IT IS USED TO REMOVE COMMENT FROM TABLE.


COMMENT ON COLUMN chethan.empid
IS 'Employee Identitiy Number'; --IT IS USED TO COMMENT ON COLUMNS OF A TABLE.

SELECT * FROM USER_COL_COMMENTS
WHERE TABLE_NAME='CHETHAN';--IT IS USED TO VIEW COMMENTS ON COLUMNS OF PARTICULAR TABLE.


COMMENT ON COLUMN chethan.empdob
IS 'Employee Date Of Birth ';

COMMENT ON COLUMN chethan.empdob
IS ' ';                           -- IT IS USED TO REMOVE COMMENTS ON COLUMNS OF PARTICULAR TABLE.

--COMPARISION(>,<,=,!=,<>) OPERATORS.

SELECT * FROM HR.employees
WHERE salary=8000;

SELECT * FROM HR.employees
WHERE salary<>8000;        --'<>' MEANS NOT EQUAL TO.

SELECT * FROM HR.employees
WHERE salary!=8000;         --'!=' MEANS NOT EQUAL TO.


SELECT * FROM HR.employees
WHERE salary < 8000; 

SELECT * FROM HR.employees
WHERE salary <= 8000; 


SELECT * FROM HR.employees
WHERE salary > 8000; 

SELECT * FROM HR.employees
WHERE salary >= 8000; 

---'BETWEEN....AND' OPERATOR.
--THE 'BETWEEN....AND' OPERATOR SELECTS VALUES WITIN A GIVEN RANGE. THE VALUES CAN BE NUMBERS OR DATE.
--THE 'BETWEEN.....AND' OPERATOR IS INCLUSIVE:BEGIN ANS END VALUES ARE INCLUDED.

SELECT * FROM HR.employees
WHERE salary BETWEEN 10000 AND 15000;
--OR
SELECT * FROM HR.employees
WHERE salary >= 10000 AND salary <= 15000;


SELECT * FROM HR.employees
WHERE salary NOT BETWEEN 10000 AND 15000;
--OR
SELECT * FROM HR.employees
WHERE salary < 10000 OR salary > 15000
ORDER BY salary DESC;

SELECT * FROM HR.employees
WHERE hire_date BETWEEN '17-06-03' AND '24-03-05'
ORDER BY hire_date DESC;

---'LIKE' OPERATOR.
--THE LIKE OPERATOR IS USED IN A 'WHERE' CLAUSE TO SEARCH FOR A SPECIFIC PATTERN IN A COLUMN.
--THERE ARE TWO WILDCARD USED IN CONJUNCTION WITH THE 'LIKE' OPERATOR.
  --THE PERCENTAGE SIGN(%) REPRESENTS ZERO, ONE OR MULTIPLE CHARACTERS.
  --THE UNDERSCORE (_) REPRESENTS A SINGLE CHARACTER.
  
SELECT * FROM HR.employees -- IT GIVES ALL THE WORDS STARTS WITH 'V'.
WHERE email LIKE 'V%';    -- WE SHOULD GIVE CAPS 'V' BECAUSE(DATA IS CASE SENSITIVE) ALL EMAILS IN TABLE ARE CAPITAL LETTER ONLY.


SELECT * FROM HR.employees
WHERE email LIKE '%VA%';   -- IT GIVES ALL THE WORDS CONTAINS 'VA' LETTERS.


SELECT * FROM HR.employees
WHERE email LIKE '%H';    --IT GIVES ALL THE WORDS END WITH 'H'.

SELECT * FROM HR.employees
WHERE email LIKE '_____'; --IT GIVES ALL THE EMAIL HAVING '5' LETTERS.

SELECT * FROM HR.employees
WHERE email LIKE '_AU%';  --IT GIVES EMAILS HAVING FIRST LETTER ANYTHING SECOND AND THIRD LETTER 'AU' AFTER ANY LETTERS.

SELECT * FROM HR.employees
WHERE email LIKE 'N%E';   -- IT GIVES ALL EMAILS LEETER STARTS WITH 'N' AND ENDS WITH 'E'.


--'IS NULL' AND 'IS NOT NULL'.
--A NULL IN A TABLE IS A VALUE IN A FIELD THAT APPEARS TO BE BLANK.
--IF A FIELD IN A TABLE IS OPERATIONAL, IT IS POSSIBLE TO UPDATE A RECORD OR INSERT A NEW RECOD WITHOUT ADDING A VALUE TO THIS FIELD. THEN THE FIELD WILL BE SAVED WITH A NULL VALUE.
--NULL VALUE IS DIFFERENT FROM A ZERO OR A FIELD THAT CONTAINS SPACE.
--IT IS NOT POSSIBLE TO TEST FOR NULL VALUES WITH COMPARISON OPERATOR, SUCH AS =,<,>.
--WE HAVE TO USE THE 'IS NULL' AND 'IS NOT NULL' OPERATOR INSTED.

SELECT * FROM chethan
WHERE empdob IS NULL; -- IT WILL GIVES ALL THE RESULTS HAVING 'empdob' IS NULL.

SELECT * FROM chethan
WHERE empdob IS NOT NULL;   -- IT WILL GIVES ALL THE RESULTS HAVING 'empdob' IS NOT NULL.

SELECT * FROM chethan
WHERE empdob = NULL; -- IT WILL NOT GIVE ANY RESULT BECAUSE 'NULL' WONT WORK WITH COMPARISION OPERATOR. 


--- 'IN' OPERATOR.
--THE 'IN' OPERATOR ALLOWS YOU TO SPECIFY MULTIPLE VALUES IN A 'WHERE' CLAUSE.
-- THE 'IN' OPERATOR IS A SHORTHAND FOR MULTIPLE 'OR' CONDITION.

SELECT * FROM HR.employees
WHERE employee_id IN(101,107,110);
--OR
SELECT * FROM HR.employees
where employee_id = 101 OR employee_id = 107 OR employee_id = 110;

SELECT * FROM HR.employees
WHERE employee_id NOT IN(101,107,110);
--OR
SELECT * FROM HR.employees
where employee_id <> 101 AND employee_id <> 107 AND employee_id <> 110;

UPDATE HR.employees
SET salary =15000
WHERE employee_id IN (101,107,110);




--- LOGICAL OPERATORS 'AND','OR','NOT'.
--'AND' OPERATOR RETURNS TRUE WHEN BOTH CONDITION ARE TRUE.
-- 'AND' OPERATOR RETURNS FALSE WHEN EITHER OF THE CONDITION IS FALSE.
-- 'OR' OPERATOR RETURNS TRUE WHEN EITHER OF THE CONDITION IS TRUE.
--'OR' OPERATOR RETURNS FALSE WHEN BOTH ARE FALSE.
--'NOT' OPERATOR RETURNS TRUE WHEN THE CONDITION IS FALSE.
--'NOT' OPERATOR RETURNS FALSE WHEN THE CONDITION IS TRUE.

SELECT * FROM HR.employees
WHERE salary = 9000 AND job_id = 'IT_PROG';

SELECT * FROM HR.employees
WHERE salary >= 9000 AND salary <= 15000;

SELECT * FROM HR.employees
WHERE salary = 9000 OR job_id = 'IT_PROG';

SELECT * FROM HR.employees
WHERE salary < 9000 OR salary > 15000;

SELECT * FROM HR.employees
WHERE NOT job_id = 'IT_PROG';

SELECT * FROM HR.employees
WHERE  email NOT LIKE 'J%';




---ARITHMETIC OPERATORS.
SELECT +3 FROM DUAL;  -- 'DUAL' MEANS DUMMY COLUMN WHICH IS USED FOR THOSE DATA DONT HAVE TABLE.

SELECT -5 FROM DUAL;

SELECT SYSDATE FROM DUAL;

SELECT salary/100 FROM HR.employees;

SELECT FIRST_NAME,TRUNC(MONTHS_BETWEEN((SYSDATE),hire_date) /12)
AS EXPERIANCE FROM hr.employees;

SELECT FIRST_NAME, salary * 12
AS Annual_Salary FROM hr.employees; 

SELECT FIRST_NAME, (salary +500)
FROM hr.employees;

SELECT FIRST_NAME,hire_date, (hire_date +50)
FROM hr.employees;




--- CONCATENATION (CONCAT) OPERATION.

SELECT 'Employee First Name is ' || first_name
FROM hr.employees;

SELECT first_name || 'is from ' || job_id 
FROM hr.employees;

SELECT CONCAT(first_name,' salary is ') || salary
FROM hr.employees;

SELECT CONCAT(CONCAT(first_name,' salary is '),salary)
FROM hr.employees;



---JOINING COLUMNS OF SAME TABLE WITH ADDING STRINGS BETWEEN THEM(GIVES SENTENCE FORMATE). 
SELECT nse_code  ||' Have Price '|| price ||' Belongs To '||sector || 'And Its Industry Is '||industry
FROM BSEIT;


--- 'ALIAS' OPERATOR.

SELECT first_name,(salary * 12) AS "Annual_Salary"
FROM hr.employees;

SELECT first_name AS "Employee_Name", salary
FROM hr.employees;

SELECT B.COMPANY, c.emppf 
FROM BSEIT1 B,chethan C;             -- IT JOINS THE TABLES.

SELECT B.COMPANY, B1.SECTOR, B1.PRICE
FROM BSEIT1 B,BSEIT1 B1;                -- IT CROSS JOINS THE TABLES.



---'ORDER BY' CLAUSE.

SELECT * FROM hr.employees
ORDER BY department_id ASC;

SELECT * FROM hr.employees
ORDER BY first_name DESC;

SELECT * FROM hr.employees
WHERE salary > 8000
ORDER BY first_name ASC;

SELECT * FROM hr.employees
ORDER BY first_name DESC , last_name ASC;

SELECT first_name,(salary * 12) AS "Annual_Salary"
FROM hr.employees
ORDER BY "Annual_Salary" DESC; -- WE USED ALIAS "Annual_Salary" in 'ORDER BY' CLAUSE.



----"SET OPERATORS".
--SET OPERATOR COMBINE THE RESULTS OF TWO OR MORE QUERIES INTO SINGLE RESULT.
--QUERIES CONTAINING 'SET' OPERATORS ARE CALLED COMPOUND QUERIES.


--'UNION' OPERATORS.
--THE UNION OPERATOR RETURNS ALL ROWS SELECTED BY EITHER QUERY.
--USE THE 'UNION' OPERATORS TO RETURNS ALL ROWS FROM MULTIPLE TABLES AND ELIMINATE ANY DUPLICATE ROWS.
--THE NUMBER OF COLUMNS AND THE TYPES OF THE COLUMNS BEING SELECTED SHOULD  BE "IDENTICAL" IN ALL THE 'SELECT' STATEMENTS USED IN THE QUERY.
--THE NAMES OF THE COLUMNS NEED NOT BE "IDENTICAL".
--THERE MUST BE SAME NUMBER OF COLUMNS PRESENT IN BOTH SELECTED STATEMENTS.

CREATE TABLE FOOTBALL
(
TNO NUMBER(10) PRIMARY KEY,
NAME VARCHAR2(10),
SECTION VARCHAR2(20)
);

INSERT INTO FOOTBALL VALUES('1','KING','SECTIONA')
INSERT INTO FOOTBALL VALUES('2','PETER','SECTIONB')
INSERT INTO FOOTBALL VALUES('3','JACOB','SECTIONC')

SELECT * FROM FOOTBALL;

CREATE TABLE HOCKEY
(
NAME VARCHAR2(10),
SECTION VARCHAR2(20)
);

INSERT INTO HOCKEY VALUES('1','KING','SECTIONA')
INSERT INTO HOCKEY VALUES('3','JACOB','SECTIONC')
INSERT INTO HOCKEY VALUES('4','ANNISON','SECTIONA')

SELECT * FROM HOCKEY;


SELECT * FROM FOOTBALL
UNION
SELECT * FROM HOCKEY;  -- IT REMOVE DUPLICATE ROWS AND JOINS UNIQUE ROWS.


---'UNION ALL' OPERATOR.
--THE 'UNION ALL' OPERATOR RETURNS ALL ROWS FORM MULTIPLE TABLES AND IT WILL NOT ELIMINATE ANY DUPLICATE ROWS..

SELECT * FROM FOOTBALL
UNION ALL
SELECT * FROM HOCKEY;  -- IT WILL NOT REMOVE DUPLICATE ROWS AND JOINS ALL ROWS.


SELECT * FROM FOOTBALL
UNION
SELECT * FROM chethan; --IT WONT GIVE RESULT BESAUSE THE NUMBER OF COLUMNS AND THE TYPES OF THE COLUMNS(NUMBER,VARCHAR2 ETC) ARE NOT SAME.

SELECT tno,name,section FROM FOOTBALL --HERE TNO AND EMPID ARE IN 'NUMBER', NAME AND EMPNAME ARE IN VARCHAR2, SECTION AND EMPPLACE ARE IN VARCHAR2. 
UNION
SELECT EMPID,EMPNAME,EMPPLACE  FROM chethan;  --IT WILL GIVE RESULT BESAUSE THE NUMBER OF COLUMNS AND THE TYPES OF THE COLUMNS ARE SAME.



---'INTERSECT' OPERATORS.
-- THE 'INTERSECT' OPERATOR RETURNS ALL ROWS COMMON TO MULTIPLE QUERIES.
-- THE NUMBER OF COLUMN AND THE DATATYPE OF THE COLUMNS BEING SELECTED BY THE 'SELECT' STATEMENT IN THE QUERIES MUST BE IDENTICAL IN ALL THE 'SELECT' STATEMENTS USED IN THE QUERY.
--THE NAMES OF THE COLUMNS NEED NOT BE IDENTICAL.

SELECT * FROM FOOTBALL
INTERSECT
SELECT * FROM HOCKEY; --IT WILL JOIN ALL ROWS OF COMMON DATA ONLY.


---'MINUS' OPERATORS.
--THE 'MINUS' OPERATOR RETURNS ROW RETURNED BY THE FIRST QUERY THAT ARE NOT PRESENT IN THE SECOND QUERY (THE FIRST 'SELECT' STATEMENT 'MINUS' THE SECOND 'SELECT' STATEMENT.
--THE NUMBER OF COLUMNS AND THE DATATYPE OF THE COLUMNS BEING SELECTED BY THE 'SELECT' STATEMENT IN THE QUERIES MUST BE IDENTICAL IN ALL THE 'SELECT' STATEMENT USED IN THE QUERY.
-- THE NAMES OF THE COLUMNS NO NEED TO BE IDENTICAL.

SELECT * FROM FOOTBALL
MINUS
SELECT * FROM HOCKEY;--IT WILL ONLY GIVE RESULTS THAT ARE PRESENT IN FIRST QUERY AND NOT PRESENT IN SECOND QUERY.



---CASE MANIPULATION FUNCTIONS(UPPER,LOWER AND INITCAP).

SELECT UPPER('chethan') FROM DUAL;

SELECT UPPER(first_name)
FROM hr.employees;

SELECT LOWER(email)
FROM hr.employees;

SELECT INITCAP(email)
FROM hr.employees;   --'INITCAP' LOOKS NOT RECOGNISED KEY WORD(COLOUR IS NOT BLUE) BUT WORKS FINE.

SELECT UPPER(first_name),salary 
FROM hr.employees.
WHERE first_name = 'David';



----"ASCII" VALUE OF ALPHABETS.
---DEPENDING ON "ASCII" VALUE DATA WILL BE SORTED.

SELECT ASCII('A') FROM DUAL;

SELECT ASCII('a') FROM DUAL;

SELECT ASCII(0) FROM DUAL;

SELECT ASCII(1) FROM DUAL;

SELECT ASCII(9) FROM DUAL;





--- "LENGTH' FUNCTION.
SELECT LENGTH('chethan') FROM DUAL;--IT GIVES NUMBER OF CHARACTERS PRESENT IN A STRING (HERE LENGTH IS 7).

SELECT LENGTH(' chethan') FROM DUAL;--IT ALSO COUNT SPACE PRESENT IN STRING (HERE LENGTH IS "8" ( "7" CHARACTER AND "1" SPACE)).

SELECT LENGTH('RAMESH KUMAR DAMANI') FROM DUAL;--IT ALSO COUNT SPACE PRESENT IN STRING (HERE LENGTH IS "19" ("16" CHARACTER AND "3" SPACE)).

SELECT first_name,LENGTH(First_Name) FROM hr.employees;



-----"REVERSE" FUNCTUION.
SELECT FIRST_NAME,REVERSE(FIRST_NAME), EMAIL, REVERSE(EMAIL)  FROM EMPLOYEES;---WE CAN ONLY REVERSE CHAR OR VARCHAR DATA TYPES(NOT ABLE TO REVERSE NUMBER,DATE).


---CHARACTER MANIPULATION FUMNCTION
--'INSTR()' FUNCTION.
--'INSTR' FINDS NUMERIC POSITION OF THE FIRST OCCURANCR OF A NAME CHARACTER.
--'INSTR' PERFORMS A CASE-SENSITIVE SEARCH.
---SYNTAX FOR "INSTR" = SELECT INSTR(COLUMN OR STRING, WHICH CHARACTER TO FIND,CHARACTER TO FIND AFTER WHICH PLACE,PARTICULAR FIRST OR SECOND OR THIRD LETTER)
---"HERE ALWAYS COUNT STARTS FROM FIRST LETTER ONLY".

SELECT INSTR('Oracle Tutorial','a') FROM DUAL;--THE LETTER 'a'("ORA") IS IN THIRD PLACE IN THE WORD 'Oracle' COUNT START POSITION IS 1st LETTER.
--OR
SELECT INSTR('Oracle Tutorial','a',1,1) FROM DUAL;--COUNT STATRS FROM LETTER 1('O') AND FIRST LETTER 'a'("ORA") is in 3rd place.

SELECT INSTR('Oracle Tutorial','A') FROM DUAL; -- NO RESULT BECAUSE THERE IS NO UPPER CASE LETTER 'A'.

SELECT INSTR('Oracle class','a',6) FROM DUAL;---AFTER "6"(" CLA") CHARACTER FIRST "a"(class) IS AT 10th("ORACLE CLA) PLACE(IF NOT MENTION COUNT STARTS FROM FIRST LETTER ONLY).

SELECT INSTR('Oracle Tutorial','a',4) FROM DUAL;--"a" CHARACTER AFTER 4th("LE TUTORIAL") LETTER IS IN 14th("Oracle Tutoria") ("a" IN "TUTORIAL" STRING INCLUDE SPACE ALSO) PLACE.

SELECT INSTR('Oracle Tutorial','a',2) FROM DUAL;--"a" CHARACTER AFTER 2nd LETTER IS IN 3rd ("a" IN "ORACLE" STRING) PLACE.

SELECT INSTR('Oracle Tutorial','a',1,2) FROM DUAL;--COUNT STARTS FROM LETTER 1st('o') AND 2nd 'a'IS IN 14th PLACE.

SELECT INSTR('Oracle Tutorial','a',4,2) FROM DUAL;--NO RESULT BECAUSE ONLY ONE LETTER "a" AFTER 4th CHARACTER(ONLY ONE "a" IN STRING "LE TUTORIAL").

SELECT INSTR('DATA DESIGN','D',4,1) FROM DUAL;--"1" MEANS FIRST "D" CHARACTER AFTER 4th(" DESIGN") CHARACTER IS IN 6th("DATA D") PLACE.

SELECT INSTR('Oracle Tutorial','a',-4) FROM DUAL;--WE ARE ASIGNED TO SEARCH '-4' SO MINUS SIGN INDICATES COUNT STARTS FROM END.

SELECT INSTR('Oracle Tutorial','a',-1) FROM DUAL;

SELECT INSTR('Oracle Tutorial','a',-1,2) FROM DUAL;

SELECT first_name, INSTR(first_name,'a') 
FROM hr.employees;

SELECT INSTR('Oracle Tutorial For Beginners','e',7,3) FROM DUAL;--NO RESULT BECAUSE NO 3rd 'e' AFTER 7th PLACE.



---'SUBSTR' FUNCTION.
--SYNTAX = SUBSTR(string,start_position(lenght)).
--- STARTING_POSITION (LENGHT) POSITIVE NUMBER STATRS FROM "START OF STRING" AND NEGATIVE NUMBER STARTS FROM END OF STRING(REVERSE).
SELECT SUBSTR('Oracle Tutorial',1) FROM DUAL;

SELECT SUBSTR('Oracle Tutorial',2) FROM DUAL;

SELECT SUBSTR('Oracle Tutorial',5) FROM DUAL;

SELECT SUBSTR('Oracle Tutorial',0) FROM DUAL;--IT WILL CONSIDER START POSITION AS 1.

SELECT SUBSTR('Oracle Tutorial',-1) FROM DUAL;--IT SHOWS LAST LETTR 'L' ONLY BECAUSE FOR MINUS INDICATE COUNT STARTS FROM END.

SELECT SUBSTR('Oracle Tutorial',-8) FROM DUAL;--START POSITION IS 8th LETTER FROM END BECAUSE '-8'.

SELECT SUBSTR('Oracle Tutorial',1,6) FROM DUAL;--STARTS POSITION FIRST LETTER AND STRING LENGTH IS 6 LETTER..

SELECT SUBSTR('Oracle Tutorial',1,-1) FROM DUAL;-- NO RESULT BECAUSE '-1' MEANS NO LENGTH.

SELECT SUBSTR('Oracle Tutorial',-9,5) FROM DUAL;

SELECT first_name,SUBSTR(first_name,1,3)FROM hr.employees;

SELECT first_name,SUBSTR(first_name,3,4)FROM hr.employees; --START POSITION IS 3rd LETTER AND LENGHT 4 LETTER

SELECT SUBSTR('Oracle Tutorial For Beginners',21,5) FROM DUAL;


---'LPAD' AND 'RPAD' FUNCTION.
--'LPAD' FUNCTION PADS THE LEFT SIDE OF A STRING WITH A SPECIFIC SET OF CHARACTERS.
--'RPAD' FUNCTION PADS THE RIGHT SIDE OF A STRING WITH A SPECIFIC SET OF CHARACTERS.
--LPAD(string,padded_length(pad_string))
SELECT LPAD('Oracle',3,'@') FROM DUAL;

SELECT RPAD('Oracle',3,'@') FROM DUAL;

SELECT LPAD('Oracle',10,'@') FROM DUAL;

SELECT RPAD('Oracle',10,'@') FROM DUAL;

SELECT RPAD('Oracle',-1,'@') FROM DUAL;

SELECT RPAD('Oracle',10,'$') FROM DUAL;

SELECT RPAD('Oracle',10,'CY') FROM DUAL;

SELECT first_name,LPAD(salary,7,'$') FROM hr.employees;



---'TRIM','LTRIM','RTRIM' FUNCTIONS.
--'TRIM' SYNTAX = TRIM(((LEADING,TRAILING,BOTH)trim_character FROM)string).

SELECT TRIM(LEADING '0' FROM '0005489') FROM DUAL;

SELECT TRIM(TRAILING '0' FROM '5478000') FROM DUAL;

SELECT TRIM(BOTH '0' FROM '0005478000') FROM DUAL;

SELECT TRIM('0' FROM '0000345000') FROM DUAL;

SELECT TRIM('K' FROM 'KKK345KK') FROM DUAL;

SELECT REPLACE(TRIM('       WELL COME    '),' ',NULL) FROM dual; ---WE CANNOT REMOVE SPACE BETWEEN WORDS SO WE USED TO REPLACE SPACE BY NULL OR ''.




--'LTRIM' SYNTAX = LTRIM(string(trim_string)).

SELECT LTRIM('oracle tutorial') FROM DUAL;

SELECT LTRIM('000354','0') FROM DUAL;

SELECT LTRIM('000354','03') FROM DUAL;

SELECT LTRIM('wohoracle','who') FROM DUAL;





---'RTRIM'(string(trim_string)).

SELECT RTRIM('oracle tutorial') FROM DUAL;

SELECT RTRIM('354000','0') FROM DUAL;

SELECT RTRIM('354300','03') FROM DUAL;

SELECT RTRIM('oraclewoh','who') FROM DUAL;

SELECT employee_id,first_name, LTRIM(first_name, 'Su')  
FROM  hr.employees;


---'REPLACE' FUNCTION.
--SYNTAX = REPLACE(string,string_to_replace(replacement_string)).
--REPLACE USED TO REPLACE ONLY ONE STRING AT A TIME.

SELECT REPLACE('SQL Tutorial', 'SQL')FROM DUAL;--REMOVES ONLY 'SQL' STRING BECAUSE WE DONT SPECIFY PROPERLY.

SELECT REPLACE('456Tutorial', '456')FROM DUAL;

SELECT REPLACE('456Tutorial456', '456')FROM DUAL;

SELECT REPLACE('SQL Tutorial', 'SQL','Oracle')FROM DUAL;-- HERE IT REPLACES 'SQL' FROM 'Oracle'.

SELECT REPLACE('456Tutorial', '456','Oracle')FROM DUAL;-- HERE IT REPLACES '456' FROM 'Oracle'.

SELECT REPLACE('456456Tutorial', '456','Oracle')FROM DUAL;-- HERE IT REPLACES '456' FROM 'Oracle' TWO TIMES.

SELECT employee_id,first_name,REPLACE(first_name,'Valli','Dalli') FROM hr.employees;

SELECT PHONE_NUMBER, '+91-'|| REPLACE(PHONE_NUMBER,'.',NULL) AS PHONE_NUMBER FROM HR.EMPLOYEES;---REPLCES DOT BY NULL.

SELECT PHONE_NUMBER, '+91-'|| SUBSTR(REPLACE(PHONE_NUMBER,'.',NULL),1,5)||'-'||SUBSTR(REPLACE(PHONE_NUMBER,'.',NULL),6,5) AS PHONE_NUMBER FROM HR.EMPLOYEES;


--EMAIL VALIDATION

WITH DT AS(SELECT 'RAMESHKUMAR@GMAIL.COM' D FROM DUAL)
SELECT REPLACE(D,'@','') FROM DT
WHERE LENGTH(D) - LENGTH(REPLACE(D,'@',''))=1;



-----"TRANSLATE" FUNCTION.
SELECT TRANSLATE('WELLCOME TO CHENNAI','ABCDEF','WXXYZ') FROM DUAL;


--"DECODE()" FUNCTION.
--SYNTAX: SELECT DECODE(column_name, 'oldvalue1', 'newvalue1', 'oldvalue2', 'newvalue2') FROM table_name
--BY USING "DECODE" WE CAN REPLACE MULTIPLE STRING AT A TIME
SELECT first_name, Decode(first_name, 'Ellen', 'Ravi', 'Sundar', 'Kiran', 'Amit', 'Janu') FROM HR.employees;

SELECT employee_id,first_name, Decode(first_name, 'Ellen', last_name, 'Steven', salary, 'Amit', phone_number) FROM HR.employees;
--HERE FIRST_NAME IS REPLACED BY LAST_NAME AND "Steven" BY HIS SALARY AND "Amith" BY PHONE_NUMBER.

---'DUAL' TABLE.
--DUAL TABLE IS A SPECIAL TABLE WITH ONE ROW AND ONE COLUMN.
--'DUAL' TABLE IS PRESENT IN ALL ORACLE DATABASES BY DEFAULT.
--'DUAL' TABLE HAS ONE COLUMN NAMED 'DUMMY' WITH DATA TYPE VARCHAR2(1).
--THE COLUMN VALUE IS 'X'.

DESC DUAL;

SELECT * FROM DUAL;
 
SELECT COUNT(*) FROM DUAL;

SELECT 10+5 FROM DUAL;

SELECT 105 FROM DUAL;

SELECT 1050/15 FROM DUAL;

SELECT 1050*15 FROM DUAL;

SELECT 'Oracle Tutoial' FROM DUAL;

SELECT SYSDATE FROM DUAL;


----"NVL" FUNCTION.
SELECT * FROM HR.EMPLOYEES;

SELECT SALARY + COMMISSION_PCT AS TOTAL_SAL FROM HR.EMPLOYEES;----"NULL" WITH ANY AIRTHMATIC OPERATION IS "NULL ONLY".

---TO OVER COME ABOVE PROBLEM WE USE "NVL" FUNCTION.
SELECT SALARY + NVL(COMMISSION_PCT,0) TOTAL_SAL FROM HR.EMPLOYEES;


----NVL2
SELECT NVL2(4,8,12) FROM DUAL;---HERE RESULT RETURNED IS "8" BECAUSE IF FIRST ARGUMENT IS "NOT NULL" RETURNS SECOND ARGUMENT.

SELECT NVL2(NULL,8,12) FROM DUAL; ---HERE RESULT RETURNED IS  "12" BECAUSE IF THE FIRST ARGUMENT IN "NULL" THEN RETURNS THIRD ARGUMENT.

SELECT * FROM STUDENTS;

SELECT COMMISSION_PCT, NVL2(COMMISSION_PCT,'COMMISSION_ALLOTED','NOT ALLOTED') COMMISSION_STATUS FROM HR.EMPLOYEES;


----"NULLIF" FUNCTION.

SELECT NULLIF(8,8) FROM DUAL; ---HERE IF BOTH ARGUMNETS ARE SAME THEN RETURNS "NULL".

SELECT NULLIF(5,8) FROM DUAL; --- HERE IF BOTH ARGUMENTS ARE NOT SAME THEN RETURNS "FIRST ARGUMENTS".

SELECT FIRST_NAME, LAST_NAME FROM HR.EMPLOYEES WHERE FIRST_NAM = LAST_NAME;

SELECT FIRST_NAME, LAST_NAME FROM HR.EMPLOYEES WHERE NULLIF(FIRST_NAME,LAST_NAME) IS NULL;



----"COALESCE" FUNCTION.
---HERE IF commission_pct IS "NULL" IT RETURNS manager_id. IF manager_id IS ALSO "NULL" THEN RETURN department_id. IF department_id ALSO "NULL" RETURNS "0".
SELECT commission_pct,manager_id,department_id, COALESCE(commission_pct,manager_id,department_id,0) FROM employees;

select employee_id,salary,commission_pct,salary+(salary*COALESCE(commission_pct,0)) total_salary from employees;

SELECT COALESCE(mobile_no,office_no,resi_no,'no_phone_number') FROM dual;




---'ROUND' FUNCTIN.
--ROUND RETURNS A NUMBER ROUNDED TO THE NEAREST INTEGER.
--SYNTAX = ROUND(number (decimal_place)).

SELECT ROUND(123.56)FROM DUAL;--WE ARE NOT SPECIFIED SCALE SO IT ROUND ALL.

SELECT ROUND(123.564,1)FROM DUAL;--HERE IT ROUND FIRST DIGIT (56 TO 60)

SELECT ROUND(123.564,2)FROM DUAL;--HERE IT ROUND SECOND DIGIT (64 TO 60)

SELECT ROUND(123.56456,3)FROM DUAL;--HERE IT ROUND SECOND DIGIT (45 TO 50)

SELECT ROUND(123.564567,4)FROM DUAL;--HERE IT ROUND SECOND DIGIT (56 TO 60)

SELECT ROUND(123.567,2)FROM DUAL;--HERE IT ROUND SECOND DIGIT (67 TO 70)

SELECT ROUND(123.567,-1)FROM DUAL;--HERE IT ROUND ONES PLACE(ONCE PLACE DEPENDS ON TENS PLACE ROUND TO TENS PLACE) BEFORE DECIMAL (23 TO 20)

SELECT ROUND(126.567,-1)FROM DUAL;--HERE IT ROUND FIRST DIGIT BEFORE DECIMAL POINT (26 TO 30)

SELECT ROUND(123.567,-2)FROM DUAL;--HERE IT ROUND TENS PLACE(TENS PLACE DEPENDS ON HUNDRED PLACE ROUND TO HUNDRED PLACE) BEFORE DECIMAL (123 TO 100)

SELECT ROUND(188.567,-2)FROM DUAL;--HERE IT ROUND TENS PLACE(TENS PLACE DEPENDS ON HUNDRED PLACE ROUND TO HUNDRED PLACE) BEFORE DECIMAL (188 TO 200)

SELECT ROUND(188.567,-3)FROM DUAL;

SELECT ROUND(888.567,-3)FROM DUAL;



---'TRUNC' AND 'MOD' FUNCTION.
--'TRUNC' SYNTAX = TRUNC(number(decimal_place)).

SELECT TRUNC(345.1234) FROM DUAL;--IT WILL HIDE ALL DECIMAL NUMBERS.

SELECT TRUNC(345.1234,1) FROM DUAL;--IT WILL HIDE ALL DECIALS EXCEPT FIRST DECIMAL.

SELECT TRUNC(345.1234,2) FROM DUAL;--IT WILL HIDE ALL DECIALS EXCEPT FIRST AND SECOND DECIMAL.

SELECT TRUNC(345.1234,-1) FROM DUAL;--IT WILL HIDE FIRST DEGIT BEFOR DECIMAL (HERE 5 AS 0)

SELECT TRUNC(345.1234,-2) FROM DUAL;--IT WILL HIDE FIRST AND SECOND DEGIT BEFOR DECIMAL (HERE 5 AND 4 AS 0)

SELECT TRUNC(345.1234,-3) FROM DUAL;--IT WILL HIDE ALL DEGIT BEFOR DECIMAL (HERE 3,5 AND 4 AS 0)


----"CEIL" AND "FLOOR" FUNCTION.

SELECT CEIL(99.99) FROM DUAL;---GIVES NEXT VALUE.

SELECT CEIL(99.45) FROM DUAL;

SELECT FLOOR(99.99) FROM DUAL;---GIVES LAST VALUE.

SELECT FLOOR(99.45) FROM DUAL;



--'MOD' FUNCTION.
--'MOD' SYNTAX = MOD(m,n)

SELECT MOD(20,3) FROM DUAL;--IT GIVES 'REMINDER' (20/3 = REMINDER 2)

SELECT MOD(20,0) FROM DUAL;

SELECT MOD(11.5,2) FROM DUAL;

SELECT MOD(-11.5,2) FROM DUAL;

SELECT salary, MOD(salary,1000) FROM hr.employees;

SELECT * FROM HR.EMPLOYEES WHERE MOD(TO_CHAR(HIRE_DATE,'YYYY'),4) = 0;---GIVES ONLY LEAP YEARS.

SELECT * FROM HR.EMPLOYEES WHERE MOD(TO_CHAR(HIRE_DATE,'YYYY'),4) <> 0;---GIVES NON LEAP YEARS.

SELECT * FROM HR.EMPLOYEES WHERE MOD(EMPLOYEE_ID,2)=0; ---GIVES ONLY EVEN EMPLOYEE_ID.

SELECT * FROM HR.EMPLOYEES WHERE MOD(EMPLOYEE_ID,2)<>0; ---GIVES ONLY ODD EMPLOYEE_ID.



---"EXTRACT" YEAR,MONTH,DAY FROM DATE.

SELECT EXTRACT(YEAR FROM DATE '1998-03-07') FROM DUAL;

SELECT EXTRACT(MONTH FROM HIRE_DATE) "Month" FROM hr.employees;
    
SELECT EXTRACT(YEAR FROM HIRE_DATE) "Year" FROM hr.employees;
      
SELECT EXTRACT(DAY FROM HIRE_DATE) "Day" FROM hr.employees;
  
SELECT EXTRACT(Hour FROM HIRE_DATE) "Time" FROM hr.employees; 





---DATE FUNCTIONS 'MONTHS_BETWEEN' AND 'ADD_MONTHS' FUNCTION.

--'MONTHS_BETWEEN' SYNTAX = MONTHS_BETWEEN(date1,date2)

SELECT MONTHS_BETWEEN(TO_DATE('15/JULY/2018','DD/MM/YYYY'), TO_DATE('15/MAY/2018','DD/MM/YYYY')) FROM DUAL;

SELECT MONTHS_BETWEEN('16/7/2018','15/5/2018')FROM DUAL;

SELECT MONTHS_BETWEEN('30/7/2018','15/5/2018')FROM DUAL;

SELECT MONTHS_BETWEEN('15/5/2018','15/5/2018')FROM DUAL;



---FINDING DAYS BETWEEN ANY TO DATE.

SELECT ROUND(SYSDATE - HIRE_DATE,0) FROM HR.EMPLOYEES;



---'ADD_MONTHS' FUNCTION.
--'ADD_MONTHS' SYNTAX = ADD_MONTHS(date,Number_of_Months).

SELECT ADD_MONTHS('15/1/2018',1) FROM DUAL;

SELECT ADD_MONTHS('15/1/2018',2) FROM DUAL;

SELECT ADD_MONTHS('15/1/2018',12) FROM DUAL;

SELECT ADD_MONTHS('15/1/2018',-1) FROM DUAL;

SELECT ADD_MONTHS('15/1/2018',-11) FROM DUAL;



---"TO_DATE" FUNCTION.
--TO_DATE converts char of CHAR, VARCHAR2, NCHAR, or NVARCHAR2 data type to a value of DATE data type.

SELECT TO_DATE('January 15, 1989','Month dd, YYYY')  FROM DUAL;

SELECT TO_DATE('21   /JUN/2022','dd Month, YYYY')  FROM DUAL;

SELECT TO_DATE('21   /JUN/2022','DD/MM/YYYY')  FROM DUAL;


--"TO_CHAR (datetime)" FUNCTION.
--TO_CHAR (datetime) converts a datetime or interval value of DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL DAY TO SECOND, or INTERVAL YEAR TO MONTH data type to a value of VARCHAR2 data type in the format specified by the date format fmt. If you omit fmt, then date is converted to a VARCHAR2 value as follows:
--DATE values are converted to values in the default date format.TIMESTAMP and TIMESTAMP WITH LOCAL TIME ZONE values are converted to values in the default timestamp format.TIMESTAMP WITH TIME ZONE values are converted to values in the default timestamp with time zone format.Interval values are converted to the numeric representation of the interval literal.

SELECT TO_CHAR(SYSDATE, 'DAY/MON/YYYY') FROM DUAL; -- IT GIVES DATE IN THE FORM OF WORDS.

SELECT TO_CHAR(SYSDATE, 'DAY/MON/YEAR') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'MONTH') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DAY') FROM DUAL;


SELECT HIRE_DATE,TO_CHAR(HIRE_DATE, 'DAY')  DAYNAME,TO_CHAR(HIRE_DATE, 'MONTH') MONTHSNAME,TO_CHAR(HIRE_DATE, 'YYYY') YEAR  FROM HR.employees;

SELECT HIRE_DATE,TO_CHAR(HIRE_DATE, 'DAY')  DAYNAME,TO_CHAR(HIRE_DATE, 'MONTH') MONTHSNAME,TO_CHAR(HIRE_DATE, 'YYYY') YEAR  FROM HR.employees
WHERE TO_CHAR(HIRE_DATE, 'DAY') LIKE '%SUNDAY%' AND TO_CHAR(HIRE_DATE, 'MONTH') LIKE '%MAY%';

SELECT HIRE_DATE,TO_CHAR(HIRE_DATE, 'DAY')  DAYNAME,TO_CHAR(HIRE_DATE, 'MONTH') MONTHSNAME,TO_CHAR(HIRE_DATE, 'YYYY') YEAR  FROM HR.employees
WHERE TO_CHAR(HIRE_DATE, 'DAY')='WEDNESDAY' AND TO_CHAR(HIRE_DATE, 'MONTH') = 'MARCH'; --IT WILL NOT GIVE RESULT REASON EXPLINED BELOW.
--(LIKE '%SEPTEMBER%': HERE INSTED OF "=" OPERATOR USED IS "LIKE" BECAUSE DATE OR MONTH GENERATED BY ORACLE MAY CONTAIN SPACE BEFORE STRING OR AFTER STRING. DUE TO THIS IF WE GIVE COMMAND LIKE THIS((TO_CHAR(HIRE_DATE, 'MONTH')='MARCH') MAY GIVE RESULT OE MAYNOT GIVE RESULT.

SELECT to_char(1210.73, '9999.9') FROM dual;

SELECT to_char(1210.78, '$9999.9') FROM dual;

SELECT TO_CHAR(121021.73,'$9,99,999') FROM DUAL;

SELECT to_number(TO_CHAR(sysdate, 'mmddyyyy'))+1 FROM dual;

SELECT TO_CHAR(sysdate, 'HH24:MI:SS') FROM dual;   ---HH24 GIVES HOURS IN 0 TO 24.

SELECT TO_CHAR(sysdate, 'mm/dd/yyyy HH24:MI:SS') FROM dual;

SELECT TO_CHAR(sysdate, 'HH12:MI:SS AM') FROM dual;    ---HH12 GIVES HOURS IN 0 TO 12.

SELECT * FROM employees WHERE to_char(hire_date,'mmyyyy') BETWEEN '092005' AND '092006';




--- 'NEXT_DAY' FUNCTION.
--'NEXT_DAY' SYNTAX = NEXT_DAY(Date,Weekday).
SELECT SYSDATE FROM DUAL; -- IT GIVES DATE IN THE FORM OF NUMBER.

SELECT NEXT_DAY(SYSDATE,'sunday') FROM DUAL;--IT GIVES NEXT SUNDAY DATE.

SELECT NEXT_DAY(SYSDATE,'monday') FROM DUAL;--IT GIVES NEXT MONDAY DATE.

SELECT NEXT_DAY('11/08/2008','monday') FROM DUAL;



---"LAST_DAY" FUNCTION.
--LAST_DAY returns the date of the last day of the month that contains date.The last day of the month is defined by the session parameter NLS_CALENDAR. The return type is always DATE, regardless of the data type of date.

SELECT SYSDATE,
       LAST_DAY(SYSDATE) "Last",
       LAST_DAY(SYSDATE) - SYSDATE "Days Left"
  FROM DUAL; --"LAST_DAY(SYSDATE)" IT GIVES LAST DAY OF MONTH.
  

SELECT HIRE_DATE,
       LAST_DAY(HIRE_DATE) "Last",
       LAST_DAY(HIRE_DATE) - HIRE_DATE "Days Left"
  FROM hr.employees;--IT GIVES LAST DATE OF RESPECTIVE MONTH OF "HIRE_DATE" COLUMN AND DAYS LEFT IN THAT MONTH.
  


SELECT last_name, hire_date,
       TO_CHAR(ADD_MONTHS(LAST_DAY(hire_date), 3)) "Eval Date"
  FROM hr.employees
  ORDER BY last_name, hire_date;


SELECT LAST_DAY(ADD_MONTHS(SYSDATE,-1))+1 FROM DUAL;




 --- 'ROUND' IN DATE FUNCTION.
 --'ROUND' SYNTAX = ROUND(date,formate).
 
SELECT ROUND(SYSDATE) FROM DUAL; -- IT WILL ROUND TO NEXT DAY ONLY WHEN DAY'S TIME IS MORE THAN HALF DAY(TIME MORE THAN 12.00PM)

SELECT ROUND(SYSDATE,'DD') FROM DUAL; -- IT WILL ROUND TO NEXT DAY ONLY WHEN DAY'S TIME IS MORE THAN HALF DAY(TIME MORE THAN 12.00PM)
-- AFTER 12.00PM ROUND TO NEXT DYA AND LESS THAN 12.00PM ROUND TO SAME DAY.


SELECT ROUND(SYSDATE,'MONTH') FROM DUAL;--IT WILL ROUND TO NEXT MONTH ONLY WHEN SYSDSTE IS CROSSED MORE THAN HALF MONTH OR MORE THAN 15th.

SELECT ROUND(TO_DATE('20/11/2020'),'MONTH') FROM DUAL; --IT ROUND TO NEXT MONTH "12th" OR DECEMBER BECAUSE DATE IS 20th(MORE THAN 15). 

SELECT ROUND(TO_DATE('08/11/2020'),'MONTH') FROM DUAL;--IT ROUND TO SAME MONTH "11th" OR NOVEMBER BECAUSE DATE IS 8th (LESS THAN OR EQUAL 15).

SELECT ROUND(TO_DATE('16/11/2020'),'MONTH') FROM DUAL;--IT ROUND TO NEXT MONTH "11th" OR NOVEMBER BECAUSE DATE IS 15th (EQUAL TO  15)
--HERE DATE "0" OT "15th" ARE ROUND TO PREVIOUS MONTH  AND ONLY "16th" AND ABOVE ARE ROUND TO NEXT MONTH.

SELECT ROUND(TO_DATE('16/11/2020'),'YEAR') FROM DUAL;--IT WILL ROUND TO NEXT YEAR.

SELECT ROUND(TO_DATE('16/5/2020'),'YEAR') FROM DUAL;--IT WILL ROUND TO SAME YEAR.

SELECT ROUND(TO_DATE('16/6/2020'),'YEAR') FROM DUAL;--IT WILL ROUND TO SAME YEAR.
--HERE MONTHS '0' TO '6' ARE ROUND TO SAME YEAR AND MONTHS 7th TO 12th ARE ROUND TO NEXT YEAR.


SELECT ROUND(TO_DATE('24/5/2022'),'DAY') FROM DUAL;

SELECT ROUND(TO_DATE('21/5/2020'),'DAY') FROM DUAL;

SELECT ROUND(TO_DATE('29/5/2020'),'DAY') FROM DUAL;


----FIND QUARTER WISE DATE.

SELECT ROUND(TO_DATE('22-FEB-21'),'Q') FROM DUAL;---GIVES NEXT QUARTER FIRST DAY DATE.

SELECT ROUND(TO_DATE('22-MAY-21'),'Q') FROM DUAL;

SELECT ROUND(TO_DATE('22-SEPTEMBER-21'),'Q') FROM DUAL;

SELECT ROUND(TO_DATE('22-NOVEMBER-21'),'Q') FROM DUAL;



 --- 'TRUNC' IN DATE FUNCTION.
 --TRUNC(date,format).
 
SELECT TRUNC(SYSDATE) FROM DUAL;
 
SELECT TRUNC(SYSDATE,'DD') FROM DUAL;

SELECT TRUNC(SYSDATE,'MONTH') FROM DUAL;

SELECT TRUNC(TO_DATE('20/11/2020'),'MONTH') FROM DUAL;--IT TRUNC DATE TO FIST DAY OF MONTH(IT WORK REVERSE ORDER).

SELECT TRUNC(TO_DATE('20/11/2020'),'YEAR') FROM DUAL;--IT TRUNC MONTH TO FIRST MONTH(IT WORK REVERSE ORDER).

SELECT TRUNC(TO_DATE('8/07/2022'),'DAY') FROM DUAL;--IT GIVES PREVIOUS "SUNDAY" DATE.

SELECT TRUNC(TO_DATE('22-MAY-21'),'Q') FROM DUAL;---IT WILL GIVES FIRST DAY OF THE QUATER.

SELECT TRUNC(TO_DATE('22-FEB-21'),'Q') FROM DUAL;---IT WILL GIVES FIRST DAY OF THE QUATER

SELECT LAST_DAY(TRUNC(TO_DATE('22-FEB-21'),'Q')+75) FROM DUAL;---IT WILL GIVES LAST DAY OF THE QUATER

SELECT LAST_DAY(TRUNC(TO_DATE('22-MAY-21'),'Q')+75) FROM DUAL;---IT WILL GIVES LAST DAY OF THE QUATER.




---CONVERSION FUNCTION (TO_DATE, TO_NUMBER, TO_CHAR).
--TO_DATE (string,format,NLS).

SELECT TO_DATE('2018/11/23','YYYY/MM/DD') FROM DUAL;

SELECT TO_DATE('20181123','YYYY/MM/DD') FROM DUAL;

SELECT TO_DATE('20102022','DD/MM/YYYY') FROM DUAL;

SELECT TO_DATE('20/NOV/2022','DD/MM/YYYY') FROM DUAL;

SELECT TO_DATE('201122','DD/MM/YY') FROM DUAL;


--'TO_NUMBER' FUNCTION.
--TO_NUMBER(string,format,NLS).

SELECT TO_NUMBER('4321','9999') FROM DUAL;

SELECT TO_NUMBER('4321.50','9999.99') FROM DUAL;


---'TO_CHAR' FUNCTION.
--TO_CHAR(string,format,NLS).

SELECT TO_CHAR('567890.50','9,99,9999.00') FROM DUAL;

SELECT TO_CHAR('567890.50','$99,99,999.00') FROM DUAL;

SELECT TO_CHAR(SYSDATE) FROM DUAL;

SELECT TO_CHAR(SYSDATE,'MONTH/DAY/YEAR') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'MM-DAY-YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'month/DAY/YYYY') FROM DUAL; -- IT CONVERT MONTH TO SMALL LETTER AND DAY TO CAPITAL LETTER.

SELECT TO_CHAR(SYSDATE,'MM-DDth-YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'MM-ddth-YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'DDSPTH- Month-year') FROM DUAL;---"DDSPTH" GIVES ALL DATE CHARACTER IN CAPS LETTER.

SELECT TO_CHAR(SYSDATE,'DdSPTH- MONTH-Year') FROM DUAL;---"DdSPTH" GIVES ALL DATE CHARACTER IN SMALL LETTER.

SELECT TO_CHAR(SYSDATE,'Ddth "of" Month') FROM DUAL;

SELECT TO_CHAR(HIRE_DATE,'DD/MONTH/YYYY'), TO_CHAR(salary,'$99,999') FROM hr.employees;


---AGGREGATE FUNCTIONS (SUM,AVG,MAX,MIN,MEDIAN,ABS AND COUNT).

SELECT ABS(-52) FROM DUAL;

SELECT SUM(salary) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT AVG(salary) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT MAX(salary) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT MAX(HIRE_DATE) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT MEDIAN(SALARY) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT MIN(HIRE_DATE) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT manager_id, employee_id, salary,
MEDIAN(salary) OVER (PARTITION BY manager_id) "Median by Mgr"
FROM hr.employees
WHERE department_id > 60
ORDER BY manager_id, employee_id;

SELECT MIN(salary) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT COUNT(*) FROM hr.employees
WHERE job_id='FI_ACCOUNT';

SELECT COUNT(first_name) FROM hr.employees;

SELECT COUNT(*) FROM hr.employees;



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------PARTITION ONLY SUPPORT TO ENTERPRISE EDDITION.
---'RANGING PARTITION'  FUNCTION.
--IT IS POWERFULL FUNCTIONALITY TO LOGICALLY PARTITION OBJECT INTO SMALLER PIECES.
--PARTITIONING ENABLES DATA MANAGEMENT OPERATIONS SUCH DATA LOADS, INDEX CREATION AND REBULDING, AND BACKUP / RECOVERY AT THE PARTITION LEVEL,RATHER THAN ON THE ENTIRE TABLE. THIS RESULTS IN SIGNIFICANTLY REDUCED TIMES FOR THESE OPERATIONS.
---WHY PARTITION.
--PERFORMANCE: PARTITIONING IMPROVES QUERY PERFORMANCE. IN MANY CASES, THE RESULTS OF A QUERY CAN BE ACHIEVED BY ACCESSING A SUBSET OF PERTITIONS,RATHER THAN THE ENTIRE TABLE.
--AVAILABILITY: PARTITIONING INCREASES THE AVAILABILITY OF MISSION CRITICAL DATABASES IF CRITICAL TABLES AND INDEXES ARE DIVIDED INTO PARTITIONS TO REDUCE THE MAINTENANCE WINDOW, RECOVERY TIMES, AND IMPACT OF FAILURES.
--TYPES ARE RANGE PARTITIONING, LIST PARTITIONING, HASH PARTITIONING, COMPOSITE PARTITIONING.

--'RANGE PARTITIONING'
--USEFUL WHEN DATA HAS LOGICAL RANGES INTO WHICH IT CAN BE DISTRIBUTED.EXAMPLE A RANGE OF DATES, OR NUMBERS.
--DATA IS MAPPED TO PARTITIONS BASED ON RANGES OF PARTITION KEY VALUES ESTABLISHED FOR EACH PARTITION.
--EACH PARTITION HAS A VALUES LESS THAN CLAUSE, WHICH SPECIFIES A NO INCLUSIVE UPPER BOUND FOR THE PARTITION.
-- A MAXVALUE LITERAL CAN BE DEFINED FOR THE HIGHEST PARTITION. MAXVALUE REPRESENTS A VIRTUAL INFINITE VALUES.

CREATE TABLE emp1
(
empid number(6),
empdoj date,
empsalary number(6)
)
PARTITION BY RANGE(empsalary)
(
PARTITION P1 VALUES LESS THAN(10000),
PARTITION P2 VALUES LESS THAN(20000),
PARTITION P3 VALUES LESS THAN(30000),
PARTITION P4 VALUES LESS THAN(MAXVALUE)
)





CREATE TABLE customer
(
empid number,
dob date,
state_code CHAR(2)
)
PARTITION BY LIST(state_code)
(
PARTITION region_south VALUES('KL','TN','KA'),
PARTITION region_north VALUES('JK','PB','DL')
);

-----------------------------------------------------------------------------------------------------------------------------------------------------

---'JOIN' FUNCTIONS.

--JOIN IS USED TO COMBINE COLUMNS FROM TWO OR MORE TABLES BASED ON VALUES OF THE RELATED COLUMNS.
--TO EXECUTR A JOIN, ORACLE COMBINES PAIR OF ROWS, EACH CONTAINING ONE ROW FROM EACH TABLE, FOR WHICH A JOIN CONDITION EVALUATES TO 'TRUE'.
-- TO EXECUTE A JOINS OF THREE OR MORE TABLES,ORACLE FIRST JOINS TWO OF THE TABLES BASED ON THE JOIN CONDITION COMPARING THEIR COLUMNS AND THEN JOINS THE RESULTS TO ANOTHER TABLE BASED ON THE JOIN CONDITITONS CONTAINING COLUMNS OF THE JOINED TABLES AND THE NEW TABLE.
--ORACLE CONTINUES THIS PROCESS UNTIL ALL TABLES ARE JOINED INTO THE RESULT.

CREATE TABLE TABJOIN
(
CUSTID NUMBER(20),
CUSTNAME VARCHAR2(20),
PRODUCTID NUMBER(20));

INSERT ALL
INTO TABJOIN VALUES(100,'CHETU',10)
INTO TABJOIN VALUES(101,'RAVI',10)
INTO TABJOIN VALUES(102,'RAMU',10)
INTO TABJOIN VALUES(103,'CHANDU',10)
SELECT * FROM DUAL;


CREATE TABLE TABJOINPROD
(
PRODUCT_ID NUMBER(20),
PRICE NUMBER(20),
 QUANTITY NUMBER(20));
 

INSERT ALL
INTO TABJOINPROD VALUES(10,150,1)
INTO TABJOINPROD VALUES(20,200,5)
INTO TABJOINPROD VALUES(40,100,8)
INTO TABJOINPROD VALUES(50,120,4)
SELECT * FROM DUAL;

SELECT * FROM TABJOIN;

SELECT * FROM TABJOINPROD;



------"JOIN" OR "INNER JOIN" FUNCTION.
--'INNER JOIN' SELECTS RECORDS THAT HAVE MATCHING/COMMON VALUES IN BOTH TABLES.

--ORACLE DATABASE SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1, TABJOINPROD T2
WHERE T1.PRODUCTID=T2.PRODUCTID; 

SELECT b.company,b1.sector,b1.industry,b.median_pe,b.WEEK52_LOW
FROM BSEIT b , BSEIT1 b1
WHERE b.company=b1.company;

--"ANSI" SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1 
INNER JOIN TABJOINPROD T2
ON T1.PRODUCTID= T2.PRODUCTID; 

SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1 
JOIN TABJOINPROD T2
ON T1.PRODUCTID= T2.PRODUCTID;


SELECT b.company,b1.sector,b1.industry,b.median_pe,b.WEEK52_LOW
FROM BSEIT b
INNER JOIN BSEIT1 b1
ON b.company=b1.company;

SELECT b.company,b1.sector,b1.industry,b.median_pe,b.WEEK52_LOW
FROM BSEIT b
JOIN BSEIT1 b1
ON b.company=b1.company
WHERE b.median_pe < 25;

SELECT b.company,b1.sector,b1.industry,b.median_pe,b.WEEK52_LOW,b.NSE_CODE
FROM BSEIT b
INNER JOIN BSEIT1 b1
ON b.NSE_CODE=b1.NSE_CODE
WHERE b.NSE_CODE IN('TCS','FSL','BCG');---FILTRING ROWS WHICH ARE REQUIED.



------"OUTER JOIN" FUNCTION.
--THERE ARE THRE TYPES OF OUTER JOIN ARE "LEFT OUTER JOIN", "RIGHT OUTER JOIN" AND "FULL OUTER JOIN".

-----"LEFT OUTER JOIN" FUNCTION.
-- LEFT OUTER JOIN GIVES LEFT TABLE DATA ALONG WITH MATCHING/COMMON DATA IN BOTH TABLE.
----ORACLE DATABASE SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1, TABJOINPROD T2
WHERE T1.PRODUCTID=T2.PRODUCTID(+); ---"(+)" IS USED TO JOIN

----"ANSI" SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T1.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1 
LEFT OUTER JOIN TABJOINPROD T2
ON T1.PRODUCTID= T2.PRODUCTID; 

---FIND THE EMPLOYEE WHO DOES NOT BELONG TO ANY DEPARTMENT.
SELECT E.*,D.DEPARTMENT_NAME,D.LOCATION_ID
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE D.DEPARTMENT_NAME IS NULL;



-----"RIGHT OUTER JOIN" FUNCTION.
-- RIGHT OUTER JOIN GIVES RIGHT TABLE DATA ALONG WITH MATCHING/COMMON DATA IN BOTH TABLE.
----ORACLE DATABASE SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1, TABJOINPROD T2
WHERE T1.PRODUCTID(+)=T2.PRODUCTID; 

----"ANSI" SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1 
RIGHT OUTER JOIN TABJOINPROD T2
ON T1.PRODUCTID= T2.PRODUCTID; 


----FIND THE DEPARTMENTS DOES NOT HAVE ANY EMPLOYEES.
SELECT E.*,D.DEPARTMENT_NAME,D.LOCATION_ID
FROM EMPLOYEES E
RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE E.EMPLOYEE_ID IS NULL;


----FIND THE NUMBER EMPLOYEES WHO DOES NOT BELONG TO ANY DEPARTMENTS.
SELECT COUNT(*)
FROM EMPLOYEES E
RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE E.EMPLOYEE_ID IS NULL;





-----"FULL OUTER JOIN" FUNCTION.
--- FULL OUTER JOIN GIVES ALL DATA FROM BOTH TABLE.
-- ORACLE DATABASE DOES NOT WORKS FOR "FULL OUTER JOIN".
----"ANSI" SYNTAX.
SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1 
FULL OUTER JOIN TABJOINPROD T2
ON T1.PRODUCTID= T2.PRODUCTID; 



----"NATURAL JOIN" FUNCTION.
SELECT company,sector,industry,median_pe,WEEK52_LOW,NSE_CODE
FROM BSEIT 
NATURAL JOIN BSEIT1
WHERE NSE_CODE NOT IN('TCS','FSL','HGS','BCG','BSOFT'); -- ONLY 'NATURAL JOIN' WORKS ('JOIN' AND 'INNER JOIN' NOT WORKS HERE).


--- 'SELF JOIN' FUNCTION.
--'SELF JOIN' IS JOIN A TABLE TO ITSELF IS CALLED SELF JOIN.
-- TO JOIN A TABLE ITSELF MEANS THAT EACH ROW OF THE TABLE IS COMBINED WITH ITSELF AND WITH EVERY OTHER ROW OF THE TABLE.
--THE TABLE APPEARS TWICE IN THE FROM CLAUSE AND IS FOLLOWED BY TABLE ALIASES THAT QUALIFY COLUMN NAME IN THE JOIN CONDITION.
--THE SELF JOIN CAN BE VIEWED AS A JOIN OF TWO COPIES OF THE SAME TABLE. THE TABLE IS NOT ACTUALLY COPIED.

SELECT e1.first_name employee, e2.first_name manager, e2.salary manager_salary, e1.salary employee_salary
FROM employees e1, employees e2
WHERE e2. EMPLOYEE_ID = e1.MANAGER_ID AND e1.salary > e2.salary ;

SELECT e1.first_name employee, e2.first_name manager, e2.hire_date manager_hire_date, e1.hire_date employee_hire_date
FROM employees e1, employees e2
WHERE e2. EMPLOYEE_ID = e1.MANAGER_ID AND e1.hire_date > e2.hire_date ;


SELECT b1.nse_code  ||'  Have Price  '|| b.price ||'  Belongs To  '||b.sector || '  And Its Industry Is '||b1.industry
FROM BSEIT b 
JOIN BSEIT b1
ON b.company = b1.company;


--- 'CROSS JOIN' FUNCTION.
-- IN THIS TYPE OF JOIN DATA IN EACH AND EVERY ROW IN ONE TABLE IS ADDED TO ALL THE ROWS IN ANOTHER TABLE.
-- HERE CROSS PRODUCT OPERATION PERFORMED.
--RESULT SET WILL "m*n" ROWS i.e NUMBER OF ROWS OF LEFT TABLE * NUMBER OF ROWS OF RIGHT TABLE.

SELECT CUSTID, CUSTNAME, T1.PRODUCTID,T2.PRODUCTID, PRICE, QUANTITY 
FROM TABJOIN T1 
CROSS JOIN TABJOINPROD T2
WHERE CUSTID = 100;


----------THIS IS EXTRA CLASSIFICATION NO NEED TO STUDY AS SEPERATE CLASSIFICATION.--------------------------------------------------------------------------------------

------'EQUI JOIN' AND 'NON EQUI JOIN' FUNCTIONS.
----THESE ARE 
--'EQUI' JOIN RETURNS THE MATCHING COLUMN VALUES FROM THE SPECIFIED TABLES.EQUI JOIN USES COMPARISON OPERATOR (=) IN THE WHERE CLAUSE TO REFER EQUALITY.
--'EQUI' JOIN WILL NOT ALLOW OTHER COMPARISION OPERATOR SUCH AS <,>,<=,>= etc.

SELECT b.company,b1.sector,b1.industry,b.median_pe,b.WEEK52_LOW
FROM BSEIT b , BSEIT1 b1
WHERE b.company=b1.company;--IT WORKS SAME AS JOIN/INNER JOIN.


--THE 'NONEQUIJOIN' IS A JOIN WHICH MATCH COLUMN VALUES FROM DIFFERENT TABLE BASED ON A INEQUALITY (INSTED OF EQUAL SIGN LIKE >,<,>=,<=) EXPRESSION.
--THE VALUE OF THE JOIN COLUMN IN EACH ROW IN THE SOURCE TABLE IS COMPARED TO THE CORRESPONDING VALUES IN THE TARGET TABLE.
--A MATCH IS FOUND IF THE EXPRESSION BASED ON AN INEQUALITY OPERATOR USED IN THE JOIN, EVALUATES TO TRUE.

SELECT b.company,b1.sector,b1.industry,b.median_pe,b.WEEK52_LOW,B.PRICE
FROM BSEIT b , BSEIT1 b1
WHERE B.price BETWEEN 100 AND 500 AND B1.MEDIAN_PE < 25 ;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- ROWNUM' FUNCTION
-- HERE WE USE TABLE NAME.
SELECT ROWNUM from HR.employees; --IT GIVES FULL ROW NUMBER HERE 107 RECORDS.

SELECT ROWNUM from HR.employees
WHERE ROWNUM <= 25;             --HERE WE RESTRICT TO CERTAIN NUMBER OF ROWS ONLY.


-- HERE WE DONT USE ANY TABLE NAME.
SELECT ROWNUM,LEVEL FROM DUAL
CONNECT BY LEVEL <= 15;


SELECT ROWNUM,LEVEL FROM DUAL
CONNECT BY LEVEL <= 105;

SELECT ROWNUM, 
            SUBSTR(S,ROWNUM,1) OUTPUT1
FROM (SELECT 'WELCOME' S FROM DUAL)
CONNECT BY LEVEL <= LENGTH(S);


SELECT ROWNUM, 
            SUBSTR(S,ROWNUM,2) OUTPUT1
FROM DUAL,(SELECT 'WELCOME' S FROM DUAL)
CONNECT BY LEVEL <= LENGTH(S);

SELECT ROWNUM, 
            SUBSTR(S,ROWNUM,2) OUTPUT1
FROM DUAL,(SELECT 'IWELCOMEYOU' S FROM DUAL)
CONNECT BY LEVEL <= 10;

SELECT ROWNUM, 
            SUBSTR(S,ROWNUM,4) OUTPUT1
FROM DUAL,(SELECT 'IWELCOMEYOUALL' S FROM DUAL)
CONNECT BY LEVEL <= 12;





---FINDING DEPENDENT PATH OF A DATA.

SELECT EMPLOYEE_ID,FIRST_NAME,MANAGER_ID,SYS_CONNECT_BY_PATH(MANAGER_ID, '--->')
FROM hr.employees
START WITH MANAGER_ID='100'
CONNECT BY PRIOR EMPLOYEE_ID=MANAGER_ID;

SELECT EMPLOYEE_ID,FIRST_NAME,MANAGER_ID,SYS_CONNECT_BY_PATH(MANAGER_ID, '--->')
FROM hr.employees
START WITH MANAGER_ID='101'
CONNECT BY PRIOR EMPLOYEE_ID=MANAGER_ID;

SELECT EMPLOYEE_ID,FIRST_NAME,MANAGER_ID,SYS_CONNECT_BY_PATH(MANAGER_ID, '--->')
FROM hr.employees
START WITH MANAGER_ID='102'
CONNECT BY PRIOR EMPLOYEE_ID=MANAGER_ID;


SELECT SUM(SALARY)
FROM hr.employees
START WITH MANAGER_ID='102'
CONNECT BY PRIOR EMPLOYEE_ID=MANAGER_ID;---SUM OF SALARY OF ALL EMPLOYEES INCLUDING HIM ALSO.



SELECT EMPLOYEE_ID,FIRST_NAME,MANAGER_ID,SALARY,
(SELECT SUM(SALARY)
FROM HR.EMPLOYEES
START WITH FIRST_NAME=A.FIRST_NAME
CONNECT BY PRIOR EMPLOYEE_ID=MANAGER_ID) GROUP_SALARY
FROM HR.EMPLOYEES A;



-----------------------------------------------------------------------------------------------------------------------------------------------------------------
---"PARTITION BY" FUNCTION.
---ALMOST EQUALENT TO GROUP BY.
SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,SALARY,JOB_ID,DEPARTMENT_ID,
    TRUNC(AVG(salary) OVER(PARTITION BY JOB_ID)) AVG_SAL
        FROM hr.employees;
---OR

SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,SALARY,JOB_ID,DEPARTMENT_ID,
    TRUNC(AVG(salary) OVER(PARTITION BY DEPARTMENT_ID)) AVG_SAL
        FROM hr.employees;
---OR

SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,MANAGER_ID,SALARY,JOB_ID,DEPARTMENT_ID,
    TRUNC(SUM(salary) OVER(PARTITION BY MANAGER_ID)) SUM_SAL, TRUNC(AVG(salary) OVER(PARTITION BY JOB_ID)) AVG_SAL
        FROM hr.employees;


--------------------------------------------------------------------------------------------------------------------------------------------------------------------
----REGEXP_FUNCTIONS.

----a)."REGEXP_COUNT" FUNCTION.
-- IT WILL GIVE NUMBER OF TIMES CHARACTER PRESENT IN A STRING(ONLY '.' NOT WORK PROPERLY).

SELECT REGEXP_COUNT('123123123123123', '123', 1) REGEXP_COUNT FROM DUAL;--COUNT STARTS FROM FIRST CHARACTER,HERE '123' REPEATING 5 TIMES.

SELECT REGEXP_COUNT('123123123123', '123', 3) COUNT FROM DUAL;-- COUNT STARTS AFTER 3 CHARACTER, HERE '123' REPEATING 3 TIMES AFTER 3 CHARACTER..

SELECT regexp_count('SHIVARAJ','A') FROM DUAL; --"A" IS REPEATED 2 TIMES HERE.

SELECT regexp_count('SHI,VA,RA,J',',') FROM DUAL; --"," IS REPEATED 3 TIMES HERE.

SELECT regexp_count('SH@I@VA@RA@J','@') FROM DUAL; --"@" IS REPEATED 4 TIMES HERE.

SELECT regexp_count('SH#I#V#A#RA#J','#') FROM DUAL; --"#" IS REPEATED 5 TIMES HERE.

SELECT regexp_count('SH_I.V$A-RA<J','<') FROM DUAL; --"#" IS REPEATED 5 TIMES HERE.

SELECT PHONE_NUMBER,regexp_count(PHONE_NUMBER,'5') FROM hr.employees; 

SELECT PHONE_NUMBER,regexp_count(PHONE_NUMBER,'1') FROM hr.employees;

SELECT COMPANY,DATE1,regexp_count(DATE1,'-') FROM BSEIT1;

SELECT COMPANY,regexp_count(COMPANY,'h') FROM BSEIT1;



----b)."REGEXP_REPLACE" FUNCTION.
---IT IS USED TO REPLACE A CHARACTER OR INSERT NEW CHARACTR etc.

SELECT REGEXP_REPLACE(FIRST_NAME,'(.)','\1 ') FROM EMPLOYEES; ---IT RETURNS "SPACE" BETWEEN EVERY CHARACTER.

SELECT REGEXP_REPLACE(FIRST_NAME,'(.)','\1*') FROM EMPLOYEES; ---IT RETURNS "*" BETWEEN EVERY CHARACTER.

SELECT REGEXP_REPLACE(FIRST_NAME,'(.)','\1-->') FROM EMPLOYEES; ---IT RETURNS "-->" BETWEEN EVERY CHARACTER.



------------------------------------------------------------------------------------------------------------------------------------------------
----ARITHMATIC FUNCTIONS.

--"SIGN FUNCTION" FUNCTION.
--IT GIVES SIGN OF ANY SUMBER.
SELECT SIGN(-20) "Sign" FROM DUAL;

SELECT SIGN(20) "Sign" FROM DUAL;

SELECT SIGN(20-10-15) "Sign" FROM DUAL;


--"SQRT" SQUARE ROOT FUNCTION.
SELECT SQRT(25) "Square root" FROM DUAL;


--"POWER" FUNCTION.
SELECT POWER(3,2) "Raised" FROM DUAL;


--"LOG" FUNCTION.
SELECT LOG(10,100) "Log base 10 of 100" FROM DUAL;


--"LAN" FUNCTION.
SELECT LN(95) "Natural log of 95" FROM DUAL;


--"GRATEST" FUNCTION.
SELECT GREATEST('HARRY', 'HARRIOT', 'HAROLD') "Greatest" FROM DUAL;

SELECT GREATEST (1, '3.9', '2.4') "Greatest" FROM DUAL;


--"LEAST" FUNCTION.
SELECT LEAST('HARRY','HARRIOT','HAROLD') "Least" FROM DUAL;

SELECT LEAST (1, '2.1', '.000832') "Least" FROM DUAL;


--"FLOOR" FUNCTION.
SELECT FLOOR(15.7) "Floor" FROM DUAL;--TO PREVIOUS VALUE.


--"CEILLING" FUNCTION.
SELECT CEIL(15.7) "Floor" FROM DUAL;--TO NEXT VALUE.


--"e" FUNCTION.
SELECT EXP(4) "e to the 4th power" FROM DUAL;


--"COS,SIN,TAN" TRIGNOMETRIC FUNCTIONS.
SELECT COS(180 * 3.14159265359/180) "Cosine of 180 degrees" FROM DUAL;

SELECT SIN(180 * 3.14159265359/180) "Cosine of 180 degrees" FROM DUAL;


--"SINH,COSH" HYPERBOLIC FUNCTIONS.
SELECT COSH(0) "Hyperbolic cosine of 0"  FROM DUAL;

SELECT SINH(1) "Hyperbolic cosine of 0" FROM DUAL;
------------------------------------------------------------------------------------------------------------------------------------------------------
---"SET TIME ZONE', "SET DATE AND TIME FORMATE" .
--IT IS USED TO SET TIME ZONE IN SYSTEM.
ALTER SESSION 
SET TIME_ZONE = '+5:30';

--IT IS USED TO SET DATE AND TIME FORMATE IN SYSTEM.
ALTER SESSION 
SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';

---"CURRENT_DATE" SHOWS PRESENT DATE AND "SESSIONTIMEZONE" SHOWS CURRENT TIME ZONE PLACE
SELECT SESSIONTIMEZONE, CURRENT_DATE FROM DUAL;

---"CURRENT_TIMESTAMP" SHOWS PRESENT DATE AND TIME ALONG WITH  "SESSIONTIMEZONE" SHOWS CURRENT TIME ZONE PLACE
SELECT SESSIONTIMEZONE, CURRENT_TIMESTAMP FROM DUAL;

--SHOWS DATABASE TIMEZONE.
SELECT DBTIMEZONE FROM DUAL;

--SHOWS SESSIONTIMEZONE.
SELECT SESSIONTIMEZONE FROM DUAL;

--"LOCALTIMESTAMP" GIVES CURRENT TIME AND LOCAL TIME.
SELECT CURRENT_TIMESTAMP, LOCALTIMESTAMP FROM DUAL;--ALTER SESSION TIME TO +5.00 AND SEE LOCAL TIME.


--"SYS_EXTRACT_UTC" EXTRACTS THE UNIVERSAL TIME.
--SYS_EXTRACT_UTC extracts the UTC (Coordinated Universal Timeformerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name. If a time zone is not specified, then the datetime is associated with the session time zone
SELECT SYS_EXTRACT_UTC(TIMESTAMP '2000-03-28 11:30:00.00 -08:00') FROM DUAL;

SELECT CURRENT_DATE FROM DUAL;

SELECT SYSDATE FROM DUAL;

SELECT CURRENT_TIMESTAMP FROM DUAL;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
---"DENSE RANK" FUNCTION.
--IT GIVES SAME RANK TO SIMILLAR VALUES(6000,7000,6000,8000 HERE 1st rank 6000,1st rank 6000, 2nd rank 7000 and 3rd rank 8000).

SELECT DENSE_RANK(15500, .05) WITHIN GROUP 
  (ORDER BY salary DESC, commission_pct) "Dense Rank" 
  FROM hr.employees;
  
  SELECT department_id, last_name, salary,
       DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary) DENSE_RANK
  FROM hr.employees WHERE department_id = 60
  ORDER BY DENSE_RANK, last_name;

 SELECT MANAGER_ID, last_name, salary,
       DENSE_RANK() OVER (PARTITION BY MANAGER_ID ORDER BY salary) DENSE_RANK
  FROM hr.employees WHERE MANAGER_ID = 100
  ORDER BY DENSE_RANK, last_name;

-----------------------------------------------------------------------------------------------------------------------------------
---"FIRST" AND "LAST" FUNCTION WITH "KEEP", "MIN" AND "DENSE_RANK".

--(MAX(SALARY)) AND MIN(SALARY) WILL GIVE SAME RESULT SHOWS BELOW.
-- HERE "FIRST" KEY WORD PLAY MAJOR ROLE IT GIVES MINIMUM VALUE.
SELECT FIRST_NAME, MIN(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER() AS MIN_SALARY FROM EMPLOYEES;
---OR 
SELECT FIRST_NAME, MAX(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER() AS MIN_SALARY FROM EMPLOYEES;


--(MAX(SALARY)) AND MIN(SALARY) WILL GIVE SAME RESULT SHOWS BELOW.
-- HERE "LAST" KEY WORD PLAY MAJOR ROLE IT GIVES MAXIMUM VALUE.
SELECT FIRST_NAME, MIN(SALARY) KEEP(DENSE_RANK LAST ORDER BY SALARY) OVER() AS MIN_SALARY FROM EMPLOYEES;
---OR 
SELECT FIRST_NAME, MAX(SALARY) KEEP(DENSE_RANK LAST ORDER BY SALARY) OVER() AS MIN_SALARY FROM EMPLOYEES;


--- USING PARTITION AND FIRST.
SELECT FIRST_NAME,DEPARTMENT_ID, MIN(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS MIN_SALARY FROM EMPLOYEES;
---OR 
SELECT FIRST_NAME,DEPARTMENT_ID, MAX(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS MIN_SALARY FROM EMPLOYEES;


--- USING PARTITION AND LAST.
SELECT FIRST_NAME,DEPARTMENT_ID, MIN(SALARY) KEEP(DENSE_RANK LAST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS MIN_SALARY FROM EMPLOYEES;
---OR 
SELECT FIRST_NAME,DEPARTMENT_ID, MAX(SALARY) KEEP(DENSE_RANK LAST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS MIN_SALARY FROM EMPLOYEES;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---"FIRST" AND "LAST" FUNCTION.
 SELECT department_id,
       MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) "Worst",
       MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) "Best"
  FROM hr.employees
  GROUP BY department_id
  ORDER BY department_id;
  

SELECT last_name, department_id, salary,
       MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct)
         OVER (PARTITION BY department_id) "Worst",
       MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct)
         OVER (PARTITION BY department_id) "Best"
   FROM hr.employees
   ORDER BY department_id, salary, last_name;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---"FIRST_VALUE" FUNCTION.

SELECT employee_id, last_name, salary, hire_date,
       FIRST_VALUE(last_name)
         OVER (ORDER BY salary ASC ROWS UNBOUNDED PRECEDING) AS fv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER BY hire_date);


SELECT employee_id, last_name, salary, hire_date,
       FIRST_VALUE(last_name)
         OVER (ORDER BY salary ASC ROWS UNBOUNDED PRECEDING) AS fv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER by hire_date DESC);
          
 -----------------------------------------------------------------------------------------------------------------------------------------------------         
          
---"LAST_VALUE" FUNCTION.         
SELECT employee_id, last_name, salary, hire_date,
       LAST_VALUE(hire_date)
         OVER (ORDER BY salary DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED
               FOLLOWING) AS lv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER BY hire_date); 
          
SELECT employee_id, last_name, salary, hire_date,
       LAST_VALUE(hire_date)
         OVER (ORDER BY salary DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED
               FOLLOWING) AS lv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER BY hire_date DESC);     
          
SELECT employee_id, last_name, salary, hire_date,
       LAST_VALUE(hire_date)
         OVER (ORDER BY salary DESC, employee_id ROWS BETWEEN UNBOUNDED PRECEDING
               AND UNBOUNDED FOLLOWING) AS lv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER BY hire_date);          
          

SELECT employee_id, last_name, salary, hire_date,
       LAST_VALUE(hire_date)
         OVER (ORDER BY salary DESC, employee_id ROWS BETWEEN UNBOUNDED PRECEDING
               AND UNBOUNDED FOLLOWING) AS lv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER BY hire_date DESC);
          
SELECT employee_id, last_name, salary, hire_date,
       LAST_VALUE(hire_date)
         OVER (ORDER BY salary DESC RANGE BETWEEN UNBOUNDED PRECEDING AND
               UNBOUNDED FOLLOWING) AS lv
  FROM (SELECT * FROM hr.employees
          WHERE department_id = 90
          ORDER BY hire_date);
          

---------------------------------------------------------------------------------------------------------------------------------------------------------
---"LAG" FUNCTION.
-- LAGS SELECTED ROW BY SPECIFIED NUMBER.

SELECT hire_date, last_name, salary,
       LAG(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal
  FROM hr.employees
  WHERE job_id = 'PU_CLERK'
  ORDER BY hire_date; --IT LAG COLUMN BY ONE ROW.

SELECT hire_date, last_name, salary,
       LAG(salary, 2, 0) OVER (ORDER BY hire_date) AS prev_sal
  FROM hr.employees
  WHERE job_id = 'PU_CLERK'
  ORDER BY hire_date; --IT LAG COLUMN BY TWO ROW.
  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
---"LEAD" FUNCTION. 
-- LEAD SELECTED ROW BY SPECIFIED NUMBER. 
SELECT hire_date, last_name,
       LEAD(hire_date, 1) OVER (ORDER BY hire_date) AS "NextHired" 
  FROM hr.employees
  WHERE department_id = 30
  ORDER BY hire_date;--IT LEAD COLUMN BY ONE ROW.
  
 SELECT hire_date, last_name,
       LEAD(hire_date, 2) OVER (ORDER BY hire_date) AS "NextHired" 
  FROM hr.employees
  WHERE department_id = 30
  ORDER BY hire_date; --IT LEAD COLUMN BY TWO ROW.
  
------------------------------------------------------------------------------------------------------------------------------- 
---"LISTAGG"  FUNCTION.
--For a specified measure, LISTAGG orders data within each group specified in the ORDER BY clause and then concatenates the values of the measure column.
--As a single-set aggregate function, LISTAGG operates on all rows and returns a single output row.
--As a group-set aggregate, the function operates on and returns an output row for each group defined by the GROUP BY clause.
--As an analytic function, LISTAGG partitions the query result set into groups based on one or more expression in the query_partition_clause.

SELECT LISTAGG(last_name, '; ')
         WITHIN GROUP (ORDER BY hire_date, last_name) "Emp_list",
             MIN(hire_date) "Earliest"
                 FROM hr.employees
                     WHERE department_id = 30;
                     

SELECT department_id "Dept.",
       LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date DESC) "Employees"
  FROM hr.employees
  GROUP BY department_id
  ORDER BY department_id;  
  
  
 
SELECT department_id "Dept.",
       LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY SALARY DESC) "Employees"
  FROM hr.employees
  GROUP BY department_id
  ORDER BY department_id;   
  
  
  
  
SELECT department_id "Dept", hire_date "Date", last_name "Name",
       LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date, last_name)
         OVER (PARTITION BY department_id) as "Emp_list"
  FROM hr.employees
  WHERE hire_date < '01-SEP-2003'
  ORDER BY "Dept", "Date", "Name";  
------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
----"LNNVL" FUNCTION.
--NNVL provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the WHERE clause of a query, or as the WHEN condition in a searched CASE expression.
--It takes as an argument a condition and returns TRUE if the condition is FALSE or UNKNOWN and FALSE if the condition is TRUE. LNNVL can be used anywhere a scalar expression can appear, even in contexts where the IS [NOT] NULL, AND, or OR conditions are not valid but would otherwise be required to account for potential nulls.


--Suppose that you want to know the number of employees with commission rates of less than 20%, including employees who do not receive commissions. The following query returns only employees who actually receive a commission of less than 20%:
SELECT COUNT(*)
  FROM hr.employees
  WHERE commission_pct < .2;
 
--To include the 72 employees who receive no commission at all, you could rewrite the query using the LNNVL function as follows: 
SELECT COUNT(*)
  FROM hr.employees
  WHERE LNNVL(commission_pct >= .2);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
----"NTILE" FUNCTION.
--NTILE is an analytic function. It divides an ordered data set into a number of buckets indicated by expr and assigns the appropriate bucket number to each row. The buckets are numbered 1 through expr. The expr value must resolve to a positive constant for each partition.
 
--NTILE is an analytic function. It divides an ordered data set into a number of buckets indicated by expr and assigns the appropriate bucket number to each row. The buckets are numbered 1 through expr. The expr value must resolve to a positive constant for each partition.
SELECT last_name, salary, NTILE(4) OVER (ORDER BY salary DESC) AS quartile
  FROM hr.employees
  --WHERE department_id = 100
  ORDER BY last_name, salary, quartile; --GROUP INTO 4 BUCKETS.
  
  
SELECT * FROM (
SELECT last_name, salary, NTILE(4) OVER (ORDER BY salary DESC) AS quartile
  FROM hr.employees
  --WHERE department_id = 100
  ORDER BY last_name, salary, quartile)
  WHERE QUARTILE = 4
  ORDER BY SALARY;   --- IT WILL MAKE 4 GROUPS, EACH HAVING 27 NUMBER OF RECORDS.
  
  
 
 
 
SELECT last_name, salary, NTILE(5) OVER (ORDER BY salary DESC) AS quartile
  FROM hr.employees
  WHERE department_id = 100
  ORDER BY last_name, salary, quartile;  --GROUP INTO 5 BUCKETS.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----"NVL" FUNCTION.

SELECT last_name, NVL(TO_CHAR(commission_pct), 'Not Applicable') commission
  FROM hr.employees
  WHERE last_name LIKE 'B%'
  ORDER BY last_name;
 
 
SELECT last_name, NVL(TO_CHAR(commission_pct), 0) commission
  FROM hr.employees
  WHERE last_name LIKE 'B%'
  ORDER BY last_name;
 
SELECT last_name, NVL(TO_CHAR(commission_pct), '') commission
  FROM hr.employees
  WHERE last_name LIKE 'B%'
  ORDER BY last_name;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
----"RANK" FUNCTION.
---RANK calculates the rank of a value in a group of values. The return type is NUMBER.
  
SELECT department_id, last_name, salary,
       RANK() OVER (PARTITION BY department_id ORDER BY salary) RANK
  FROM hr.employees WHERE department_id = 60
  ORDER BY RANK, last_name;  
  
SELECT RANK(15500, .05) WITHIN GROUP
   (ORDER BY salary, commission_pct) "Rank"
   FROM hr.employees;
  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
----"ROW_NUMBER" FUNCTION.
--OW_NUMBER is an analytic function. It assigns a unique number to each row to which it is applied in the ordered sequence of rows specified in the order_by_clause, beginning with 1.
--By nesting a subquery using ROW_NUMBER inside a query that retrieves the ROW_NUMBER values for a specified range, you can find a precise subset of rows from the results of the inner query. This use of the function lets you implement top-N, bottom-N, and inner-N reporting. For consistent results, the query must ensure a deterministic sort order.

--The following example finds the three highest paid employees in each department in the hr.employees table. Fewer than three rows are returned for departments with fewer than three employees.  
SELECT department_id, first_name, last_name, salary
FROM
(
  SELECT
    department_id, first_name, last_name, salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary desc) rn
  FROM hr.employees
)
WHERE rn <= 3
ORDER BY department_id, salary DESC, last_name;  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
---"STATS_MODE" FUNCTION.
--STATS_MODE takes as its argument a set of values and returns the value that occurs with the greatest frequency(repeat max number of times). If more than one mode exists, then Oracle Database chooses one maximum occurance value(if two or more same value present it takes least value) and returns only that one value.
--ex:(6000 occurs 2 times,7000 occurs 2times and 9000 occurs 1 time. HERE ORACLE TAKES LESAT VALUE IS 6000). 
SELECT department_id, STATS_MODE(salary) FROM hr.employees
   GROUP BY department_id
   ORDER BY department_id, stats_mode(salary);
   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
  
 SELECT last_name,SYS_CONNECT_BY_PATH(last_name, ' / ') "Path"
   FROM hr.employees
   START WITH last_name = 'Kochhar'
   CONNECT BY PRIOR employee_id = manager_id;
  
 SELECT last_name,job_id ,SYS_CONNECT_BY_PATH(last_name, '---->') "Path"
   FROM hr.employees
   START WITH job_id = 'IT_PROG'
   CONNECT BY PRIOR employee_id = manager_id;  
  
 SELECT last_name,EMPLOYEE_ID,SYS_CONNECT_BY_PATH(last_name, '<--->') "Path"
   FROM hr.employees
   START WITH  EMPLOYEE_ID= '100'
   CONNECT BY PRIOR employee_id = manager_id;  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   




---DATA VALIDATION QUERY'S
SELECT * FROM TAB WHERE tname = 'EMPLOYEES';

SELECT COUNT(*)  FROM user_tab_columns WHERE table_name='EMPLOYEES'; ---IT RETURNS NUMBER OF COLUMNS.

SELECT  column_name, data_type FROM  user_tab_columns where table_name = 'EMPLOYEES';---IT GIVES COLUMN_NAME, DATA_TYPE.

SELECT  column_name, data_length,data_precision,nullable FROM  user_tab_columns WHERE table_name = 'EMPLOYEES';---IT COLUMN_NAME, DATA_LENGTH.

SELECT column_name,constraint_name FROM user_cons_columns WHERE table_name = 'EMPLOYEES'; ---IT RETURNS COLUMN_NAME, CONSTRAINT_NAME.

SELECT constraint_name,constraint_type,search_condition FROM all_constraints WHERE OWNER='HR' AND table_name='EMPLOYEES';---GIVES OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME,SEARCH_CONDITION, R_CONSTRAINT_NAME, INDEX_NAME

SELECT * FROM all_constraints WHERE OWNER='ETL7' AND table_name='TAB_DEMO_TEST';

SELECT * FROM all_cons_columns WHERE table_name = 'STUD_CONSTRAINTS1';

SELECT * FROM all_constraints WHERE table_name = 'STUD_CONSTRAINTS1';

SELECT * FROM USER_INDEXES WHERE table_name = 'STUD_CONSTRAINTS1';

SELECT * FROM USER_IND_COLUMNS WHERE table_name = 'STUD_CONSTRAINTS1';

SELECT * FROM USER_IND_STATISTICS WHERE table_name = 'STUD_CONSTRAINTS1';

SELECT * FROM USER_IND_EXPRESSIONS WHERE table_name = 'STUD_CONSTRAINTS1';

SELECT * FROM USER_DEPENDENCIES WHERE NAME = 'EMPLOYEES';

SELECT * FROM USER_OBJECTS WHERE OBJECT_NAME = 'EMPLOYEES';

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'EMPLOYEES';

SELECT * FROM USER_VIEWS;

SELECT * FROM USER_TABLES; --- GIVES DETAILS OF ALL TABLES PRESENT IN SCHEMA.

SELECT * FROM USER_TAB_COMMENTS; ---GIVES COMMENTS ON ALL TABLES PRESENT IN SCHEMS.

SELECT * FROM USER_TAB_COMMENTS WHERE TABLE_NAME = 'CITY';      --- GIVES COMMENTS OF INDIVIDUAL TABLE.

SELECT * FROM USER_COL_COMMENTS; ---GIVES COMMENTS OF ALL COLUMNS PRESENT IN SCHEMS.

SELECT * FROM USER_COL_COMMENTS WHERE TABLE_NAME = 'CHETHAN';    ---GIVES COMMENTS OF INDIVIDUAL COLUMNS.

SELECT * FROM all_users;

SELECT * FROM user_segments;



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---"VSIZE" FUNCTION.
VSIZE returns the number of bytes in the internal representation of expr. If expr is null, then this function returns null.This function does not support CLOB data directly. However, CLOBs can be passed in as arguments through implicit data conversion.
SELECT last_name, VSIZE (last_name) "BYTES"      
  FROM hr.employees
  ORDER BY employee_id;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----"CONNECT BY" FUNCTION.

---The following hierarchical query uses the CONNECT BY clause to define the relationship between employees and managers.
SELECT employee_id, last_name, manager_id
   FROM hr.employees
   CONNECT BY PRIOR employee_id = manager_id;
   
---The next example is similar to the preceding example, but uses the LEVEL pseudocolumn to show parent and child rows.
SELECT employee_id, last_name, manager_id, LEVEL
   FROM hr.employees
   CONNECT BY PRIOR employee_id = manager_id;

---The next example adds a START WITH clause to specify a root row for the hierarchy and an ORDER BY clause using the SIBLINGS keyword to preserve ordering within the hierarchy.
SELECT last_name, employee_id, manager_id, LEVEL
      FROM hr.employees
      START WITH employee_id = 100
      CONNECT BY PRIOR employee_id = manager_id
      ORDER SIBLINGS BY last_name;

---The NOCYCLE parameter in the CONNECT BY condition causes Oracle to return the rows in spite of the loop. The CONNECT_BY_ISCYCLE pseudocolumn shows you which rows contain the cycle.
SELECT last_name "Employee", CONNECT_BY_ISCYCLE "Cycle",
   LEVEL, SYS_CONNECT_BY_PATH(last_name, '/') "Path"
   FROM hr.employees
   WHERE level <= 3 AND department_id = 80
   START WITH last_name = 'King'
   CONNECT BY NOCYCLE PRIOR employee_id = manager_id AND LEVEL <= 4;
   
---The following example returns the last name of each employee in department 110, each manager above that employee in the hierarchy, the number of levels between manager and employee, and the path between the two.
SELECT last_name "Employee", CONNECT_BY_ROOT last_name "Manager",
   LEVEL-1 "Pathlen", SYS_CONNECT_BY_PATH(last_name, '/') "Path"
   FROM hr.employees
   WHERE LEVEL > 1 and department_id = 110
   CONNECT BY PRIOR employee_id = manager_id;
   
---The following example uses a GROUP BY clause to return the total salary of each employee in department 110 and all employees below that employee in the hierarchy.
SELECT name, SUM(salary) "Total_Salary" FROM (
   SELECT CONNECT_BY_ROOT last_name as name, Salary
      FROM hr.employees
      WHERE department_id = 110
      CONNECT BY PRIOR employee_id = manager_id)
      GROUP BY name;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


---- "USER TABLES" QUERIES.
SELECT * FROM USER_DEPENDENCIES WHERE NAME = 'EMPLOYEES';

SELECT * FROM USER_OBJECTS WHERE OBJECT_NAME = 'EMPLOYEES';


SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'EMPLOYEES';

SELECT * FROM USER_VIEWS;

SELECT * FROM USER_TABLES; --- GIVES DETAILS OF ALL TABLES PRESENT IN SCHEMA.

SELECT * FROM USER_TAB_COMMENTS; ---GIVES COMMENTS ON ALL TABLES PRESENT IN SCHEMS.

SELECT * FROM USER_TAB_COMMENTS
WHERE TABLE_NAME = 'CITY';      --- GIVES COMMENTS OF INDIVIDUAL TABLE.

SELECT * FROM USER_COL_COMMENTS; ---GIVES COMMENTS OF ALL COLUMNS PRESENT IN SCHEMS.

SELECT * FROM USER_COL_COMMENTS 
WHERE TABLE_NAME = 'CHETHAN';    ---GIVES COMMENTS OF INDIVIDUAL COLUMNS.

SELECT * FROM all_users; ---IT RETURNS USERNAME, USER_ID AND CREATED DATE OF SCHEMAS.





----"PIVOT" FUNCTION.
SELECT * FROM(
                SELECT JOB_ID, DEPARTMENT_ID, SALARY FROM EMPLOYEES)
PIVOT (SUM(SALARY) 
        FOR DEPARTMENT_ID IN (10 DEPT_10,20 DEPT_20,30 DEPT_30,50 DEPT_50));


SELECT * FROM(
                SELECT DEPARTMENT_ID,JOB_ID,SALARY FROM EMPLOYEES)
PIVOT (SUM(SALARY) 
        FOR JOB_ID IN ('IT_PROG','AC_MGR','AC_ACCOUNT','ST_MAN','PU_MAN','AD_ASST','AD_VP','SH_CLERK'));
        

SELECT * FROM(
                SELECT TO_CHAR(HIRE_DATE,'YYYY'), DEPARTMENT_ID,EMPLOYEE_ID FROM EMPLOYEES)
PIVOT (COUNT(EMPLOYEE_ID) 
        FOR DEPARTMENT_ID IN (80 DEPT_80,20 DEPT_20,30 DEPT_30,50 DEPT_50));     
        
        
        
        
----"UNPIVOY" FUNCTION.
---IT CONVERTS MULTIPLE COLUMNS INTO MULTIPLE ROWS.
---STEP 1:
SELECT 
                        'WELLCOME' COL1,
                        'TO'       COL2,
                        'ORACLE'   COL3,
                        'CLASS'    COL4
                        FROM DUAL;

---STEP 2:
SELECT * FROM(
                SELECT 
                        'WELLCOME' COL1,
                        'TO'       COL2,
                        'ORACLE'   COL3,
                        'CLASS'    COL4
                        FROM DUAL)
UNPIVOT (COLUMN_VAL FOR COLUMN_NAME IN(COL1,COL2,COL3,COL4));

---OR

SELECT * FROM(
                SELECT FIRST_NAME,
                        EMAIL,
                        JOB_ID FROM EMPLOYEES)
UNPIVOT (COL_VALUE FOR COL_NAME IN (FIRST_NAME,EMAIL,JOB_ID));


----TO GENERATE RANDOM CHARACTERS.
SELECT  DBMS_RANDOM.STRING('U',1) FROM DUAL;----HERE "U" REPRESENT "UPPER CASE" AND "1" REPRESENT NUMBER OF CHARACTER TO RETURN.

SELECT  DBMS_RANDOM.STRING('U',10) FROM DUAL;----HERE "U" REPRESENT "UPPER CASE" AND "10" REPRESENT NUMBER OF CHARACTER TO RETURN.

SELECT  DBMS_RANDOM.STRING('L',10) FROM DUAL;----HERE "L" REPRESENT "LOWER CASE" AND "10" REPRESENT NUMBER OF CHARACTER TO RETURN.



----Email validation.
 WITH t AS

  (SELECT 'brucewayne.1981@gmail.com' email FROM dual

  UNION ALL

  SELECT 'clark_kent@gmail.com' FROM dual

  UNION ALL

  SELECT '1Tonystark.1980@gmail.com' FROM dual

  UNION ALL

  SELECT 'peter@parker.1989@gmail.com' FROM dual
  
  UNION ALL
  
  SELECT 'ramesh.somu2121@gmail.com' FROM dual
  

  )

SELECT *

FROM t

WHERE REGEXP_LIKE (EMAIL, '^[A-Za-z]+[A-Za-z0-9.]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$');







COMMIT;

DESC chethan;
SELECT * FROM hr.employees;
SELECT * FROM chethan1;
SELECT * FROM BSEIT1;
SELECT * FROM BSEIT;





