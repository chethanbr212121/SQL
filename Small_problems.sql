---1. HOW TO FIND SECOND HIGHEST SALARY OF A EMPLOYEE.
SELECT MAX(salary) FROM hr.employees
WHERE salary < (SELECT MAX(salary) FROM hr.employees);
--OR

SELECT MAX(salary) FROM hr.employees
WHERE salary NOT IN (SELECT MAX(salary) FROM hr.employees);

---2. DISPLAY HIGHEST PAYED EMPLOYEE IN EACH DEPARTMENT.
SELECT MANAGER_ID, MAX(SALARY) FROM hr.employees
GROUP BY MANAGER_ID ;

---3. DISPLAY NUMBER OF  EMPLOYEE IN EACH DEPARTMENT.
SELECT MANAGER_ID, COUNT(*) FROM hr.employees
GROUP BY MANAGER_ID ;

---4. FIND DUPLICATE VALUES AND IT'S FREQUENCY OF A COLUMN.
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID,COUNT(*) FROM HR.employees
GROUP BY EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID
HAVING COUNT(*) > 1;-----NO DUPLICATE FOUND.

----5. a). DISPLAY THE EMPLOYEE NAMES WHOSE NAME STARTS WITH 'M'.
--- b). DISPLAY THE EMPLOYEE NAMES WHOSE NAME ENDS WITH 'n'.
--- c). DISPLAY THE NAMES OF ALL EMPLOYEES HAVING 'm' IN ANY POSITION IN THEIR NAME. 
--- d). DISPLAY THE NAMES OF ALL EMPLOYEES WHOSE NAME DOES NOT CONTAIN 'm' IN ANY POSITION IN THEIR NAME. 

--a).DISPLAY THE EMPLOYEE NAMES WHOSE NAME STARTS WITH 'M'.
SELECT first_name FROM HR.employees
WHERE first_name LIKE 'M%';

--- b). DISPLAY THE EMPLOYEE NAMES WHOSE NAME ENDS WITH 'n'.
SELECT first_name FROM HR.employees
WHERE first_name LIKE '%n';

--- c). DISPLAY THE NAMES OF ALL EMPLOYEES HAVING 'm' IN ANY POSITION IN THEIR NAME. 
SELECT first_name FROM HR.employees
WHERE first_name LIKE '%m%';

--- d). DISPLAY THE NAMES OF ALL EMPLOYEES WHOSE NAME DOES NOT CONTAIN 'm' IN ANY POSITION IN THEIR NAME. 
SELECT first_name FROM HR.employees
WHERE first_name NOT LIKE '%m%';


-----6. a). DISPLAY NAMES OF ALL EMPLOYEES WHOSE NAME CONTAINS EXACTLY 4 LETTERS.
--- b). DISPLAY NAMES OF ALL EMPLOYEES WHOSE NAME CONTAINS THE SECOND LETTER AS "n" AND FOURTH LETTER AS "m".
--- c). DISPLAY THE EMPLOYEES NAMES AND HIRE DATES FOR THE EMPLOYEES JOINED IN THE MONTH OF DECEMBER.
--- d). DISPLAY NAMES OF THE EMPLOYEES WHOSE NAME CONTAINS EXACTLY 2 "a".
--- e). DISPLAY NAMES OF THE EMPLOYEES WHOSE NAME STARTS WITH 'J' AND ENDS WITH 's'.

--- a). DISPLAY NAMES OF ALL EMPLOYEES WHOSE NAME CONTAINS EXACTLY 4 LETTERS.
SELECT first_name FROM HR.employees
WHERE first_name LIKE '____';

--- b). DISPLAY NAMES OF ALL EMPLOYEES WHOSE NAME CONTAINS THE SECOND LETTER AS "a" AND FOURTH LETTER AS "t".
SELECT first_name FROM HR.employees
WHERE first_name LIKE '_a_t%';

--- c). DISPLAY THE EMPLOYEES NAMES AND HIRE DATES FOR THE EMPLOYEES JOINED IN THE MONTH OF DECEMBER.
SELECT first_name, hire_date FROM HR.employees
WHERE TO_CHAR(hire_date,'MM') = 12;
---OR
SELECT first_name, hire_date FROM HR.employees
WHERE TO_CHAR(hire_date,'MONTH') LIKE '%DECEMBER%'; 

--- d). DISPLAY NAMES OF THE EMPLOYEES WHOSE NAME CONTAINS EXACTLY 2 "a".
SELECT first_name FROM HR.employees
WHERE first_name LIKE '%a%a%'; 

---OR
SELECT first_name FROM HR.employees
WHERE regexp_count(first_name,'a') = 2; 



--- e). DISPLAY NAMES OF THE EMPLOYEES WHOSE NAME STARTS WITH 'J' AND ENDS WITH 's'.
SELECT first_name FROM HR.employees
WHERE first_name LIKE 'J%s'; 



----7. DISPLY "nth" ROW IN SQL.
--- a). DISPLAY "2nd" ROW OF EMPLOYEES TABLE.
--- b). DISPLAY "4th" ROW OF EMPLOYEES TABLE.
--- c). DISPLAY "2nd , 8th, and 12th" ROW OF EMPLOYEES TABLE.

--IT DISPLAY ONLY SELECTED COLUMNS OF TABLE.
SELECT * FROM(SELECT ROWNUM r,first_name,last_name,email,salary FROM HR.employees)
WHERE r = 2;--- IF WE DONT SPECIFY ALIAS "r" TO ROWNUM IT WILL NOT WORK IN WHERE CLAUSE.

--- b). DISPLAY "4th" ROW OF EMPLOYEES TABLE.
SELECT * FROM(SELECT ROWNUM r,first_name,last_name,email,salary FROM HR.employees)
WHERE r = 4; 

--- c). DISPLAY "2nd , 8th, and 12th" ROW OF EMPLOYEES TABLE.
SELECT * FROM(SELECT ROWNUM r,first_name,last_name,email,salary FROM HR.employees)
WHERE r IN (2,8,12); 


---OR
--- a). DISPLAY "2nd" ROW OF EMPLOYEES TABLE.
---IT DISPLAY ALL THE COLUMNS OF TABLE.
SELECT * FROM(SELECT ROWNUM r,HR.employees.* FROM HR.employees)
WHERE r = 2;

--- b). DISPLAY "4th" ROW OF EMPLOYEES TABLE.
SELECT * FROM(SELECT ROWNUM r,HR.employees.* FROM HR.employees)
WHERE r = 4;

--- c). DISPLAY "2nd , 8th, and 12th" ROW OF EMPLOYEES TABLE.
SELECT * FROM(SELECT ROWNUM r,HR.employees.* FROM HR.employees)
WHERE r IN (2,8,12); 





----8."INNER JOIN", "FULL JOIN","CROSS JOIN", "LEFT JOIN" AND "RIGHT JOIN".
SELECT * FROM employees;

SELECT * FROM departments;
---"INNER JOIN" FUNCTION.
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, emp.MANAGER_ID, emp.DEPARTMENT_ID,dep.DEPARTMENT_NAME, dep.LOCATION_ID
FROM employees emp
INNER JOIN departments dep
ON emp.DEPARTMENT_ID=dep.DEPARTMENT_ID;

---"Left OUTER JOIN" FUNCTION.
SELECT emp.*,dep.*
FROM employees emp
LEFT OUTER JOIN departments dep
ON emp.DEPARTMENT_ID=dep.DEPARTMENT_ID;


----9."SELF JOIN" FUNCTION.
--JOINING A TABLE WITH ITSELF IS CALLED SELF JOIN.
--COMPARING VALUES OF A VALUES WITH THE VALUES OF SAME COLUMN ITSELF OR DIFFERENT COLUMN VALUES OF THE SAME TABLE.

---a). DISPLAY EMPLOYEES DETAILS WHO ARE GETTING MORE SALARY THAN THEIR MANAGER SALARY.
---b). DISPLAY THE EMPLOYEES DETAILS WHO JOINED BEFORE THEIR MANAGER.

---a). DISPLAY EMPLOYEES DETAILS WHO ARE GETTING MORE SALARY THAN THEIR MANAGER SALARY.
SELECT e1.first_name employee, e2.first_name manager, e2.salary manager_salary, e1.salary employee_salary
FROM employees e1, employees e2
WHERE e2. EMPLOYEE_ID = e1.MANAGER_ID AND e1.salary > e2.salary ;

---b). DISPLAY THE EMPLOYEES DETAILS WHO JOINED BEFORE THEIR MANAGER.
SELECT e1.first_name employee, e2.first_name manager, e2.hire_date manager_hire_date, e1.hire_date employee_hire_date
FROM employees e1, employees e2
WHERE e2. EMPLOYEE_ID = e1.MANAGER_ID AND e1.hire_date > e2.hire_date ;


-----10.DISPLAY FIRST n ROWS AND LAST n ROWS.
--a). DISPLAY FIRST AND LAST ROW OF THE TABLE.
--b). DISPLAY LAST TWO ROWS OF THE TABLE.
--c). DISPLAY FIRST AND LAST 2 ROWS OF THE TABLE.

--a). DISPLAY FIRST AND LAST ROW OF THE TABLE.
SELECT * FROM (SELECT ROWNUM r,employees.* FROM employees)
WHERE r = 1 OR r = (SELECT COUNT(*) FROM employees);


--b). DISPLAY LAST TWO ROWS OF THE TABLE.
SELECT * FROM (SELECT ROWNUM r,employees.* FROM employees)
WHERE  r > (SELECT COUNT(*)-2 FROM employees);
--OR

SELECT * FROM (SELECT ROWNUM r,employees.* FROM employees)
WHERE  r = (SELECT COUNT(*) FROM employees) OR r = (SELECT COUNT(*)-1 FROM employees);
--OR

SELECT * FROM (SELECT ROWNUM r,employees.* FROM employees)
WHERE  r = (SELECT COUNT(*) FROM employees) OR r = (SELECT COUNT(*) FROM employees)-1;


--c). DISPLAY FIRST AND LAST 2 ROWS OF THE TABLE.
SELECT * FROM (SELECT ROWNUM r,employees.* FROM employees)
WHERE  r = 1 or r=2 OR r > (SELECT COUNT(*) FROM employees)-2;

select * from (
select e.*, rank() over(order by EMPLOYEE_ID) rank, rank() over(order by EMPLOYEE_ID desc) rank1 from employees e)
where rank in (1,2) or rank1 in (1,2);


-----11.DISPLAY "nth" HIGHEST SALARY OF A EMPLOYEE.
--DISPLAY 5th HIGHEST SALARY.
SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary DESC)
WHERE ROWNUM <= 5

MINUS

SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary DESC)
WHERE ROWNUM <= 4;


--DISPLAY 3rd HIGHEST SALARY.
SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary DESC)
WHERE ROWNUM <= 3

MINUS

SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary DESC)
WHERE ROWNUM <= 2;

--DISPLAY LAST TWO SALARY.
SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary ASC)
WHERE ROWNUM<=3

MINUS

SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary ASC)
WHERE ROWNUM<=1;


--DISPLAY 5TH LOWEST SALARY.
SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary ASC)
WHERE ROWNUM<=5

MINUS

SELECT * FROM
(SELECT DISTINCT salary FROM employees 
ORDER BY salary ASC)
WHERE ROWNUM<=4;


----12.Query a list of first_name  from employees for first_name that have an even ID number. Print the results in any order, but exclude duplicates from the answer
SELECT DISTINCT employee_id,first_name from employees
WHERE MOD(Employee_Id,2)=0;


-----13.Find the difference between the total number of first_name entries in the table and the number of distinct first_name entries in the table.
SELECT (COUNT(first_name)-COUNT(DISTINCT first_name)) FROM EMPLOYEES;

---14.P(R) represents a pattern LIKE TRIANGLE in R rows. The following pattern represents P(5):
select rpad('*', x,' *') from ( SELECT LEVEL x FROM DUAL CONNECT BY LEVEL <= 40 Order by Level desc ) where mod(x,2) = 0;

---15.Write a query to print all prime numbers less than or equal to . Print your result on a single line, and use the ampersand () character as your separator (instead of a space).
 SELECT LISTAGG(L1,'&') WITHIN GROUP (ORDER BY L1) FROM 
 (Select L1 FROM (SELECT LEVEL L1 FROM DUAL CONNECT BY LEVEL<=1000) Where L1 <> 1 
 MINUS 
 select L1 from (SELECT LEVEL L1 FROM DUAL CONNECT BY LEVEL<=1000) A , 
 (SELECT LEVEL L2 FROM DUAL CONNECT BY LEVEL<=1000) B 
 Where L2<=L1 and MOD(L1,L2)=0 AND L1<>L2 AND L2<>1); 


---16.Query the Name of any student in STUDENTS who scored higher than Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
SELECT NAME FROM STUDENTS
WHERE MARKS>75 
ORDER BY SUBSTR(NAME,-3);


CREATE TABLE STUDENTS
( ID NUMBER(20),
NAME VARCHAR2(20),
MARKS NUMBER(20)
);

INSERT ALL
INTO STUDENTS VALUES(1,'CHETHAN',52)
INTO STUDENTS VALUES(2,'RAVI',78)
INTO STUDENTS VALUES(3,'SOMU',85)
INTO STUDENTS VALUES(4,'RAKESH',90)
INTO STUDENTS VALUES(5,'RAMESH',82)
INTO STUDENTS VALUES(6,'CHETU',60)
INTO STUDENTS VALUES(7,'SHAMA',65)
INTO STUDENTS VALUES(8,'SUNIL',76)
INTO STUDENTS VALUES(9,'SANJU',58)
INTO STUDENTS VALUES(10,'SHARATH',70)
INTO STUDENTS VALUES(11,'RAMA',90)
INTO STUDENTS VALUES(12,'BHIMA',98)
INTO STUDENTS VALUES(13,'KHAN',88)
INTO STUDENTS VALUES(14,'MAHESH',84)
SELECT * FROM DUAL;

SELECT * FROM STUDENTS;

SELECT * FROM HR.employees
where MANAGER_ID = 100;

---17.WRITE QUERY TO SELECT THE EMPLOYEES WHO WERE HIRED ON SUNDAY?

SELECT * FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'DAY') LIKE  '%SUNDAY%';

SELECT * FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'FMDAY') LIKE  '%SUNDAY%';

SELECT * FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'DY') LIKE  '%SUN%';

SELECT * FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'D')= '1';


----18. HOW TO DEFINE CONSTRAINTS.
create table customer
(
cust_id number(6) primary key,
cust_name varchar2(30) not null,
mobile_no number(10) unique check (length(mobile_no)=10),
age number(3) check (age>=18),
city_id number(4) references city(city_id) 
);

select * from city;


create table city
(
city_id number(4) PRIMARY KEY,
city_name varchar2(30)
);


insert into city values (10,'Chennai');
insert into city values (20,'Pune');
insert into city values (30,'Hyd');
insert into city values (40,'Delhi');


insert into customer values (100000,'Arun',9090909090,28,20);


insert into customer values (100001,'Arun',8080808080,31,30);


insert into customer values (100002,'Vijay',5050505050,31,10);


insert into customer values (100003,'Ajith',2894738243,13,30);---AGE<18 


insert into customer values (100004,'Ramesh',2894738789,31,60);---CITY_ID 60 NOT IN PARENT TABLE.


---"check constraint (ETL7.SYS_C009162) violated","integrity constraint (ETL7.SYS_C009165) violated - parent key not found" THIS IS SYSTEM GENERATED ERROR MESSAGE HERE WE DONT KNOW FOR WHICH COLUMN HAVING CONSTRAINTS FACING ERROR.
---IN REAL PROJECT WE DONT KNOW FOR WHICH COLUMN IS DEFINED CONSTRAINTS(LIKE CHECK,UNIQUE,PRIMARY KEY etc) SO CHECK COLUMN CONSTRAINTS PERFORM BELOW QUERY'S.

SELECT * FROM ALL_CONSTRAINTS
WHERE OWNER = 'ETL7' AND TABLE_NAME='CUSTOMER'; ---HERE TABLE NAME IS CASE SENSITIVE.
---FROM THE ABOVE WE FIND UNIQUE CONTRAINTS ID IS '"SYS_C009164".

SELECT * FROM ALL_CONS_COLUMNS 
WHERE OWNER = 'ETL7' AND TABLE_NAME='CUSTOMER';---HERE '"SYS_C009164" IS "MOBILE_NO" COLUMN.

----OR WE CAN JOIN ABOVE TWO TABLE AND FIND UNIQUE CONSTRAINTS COLUMN NAME.

SELECT
A.OWNER,A.CONSTRAINT_NAME,A.CONSTRAINT_TYPE,B.TABLE_NAME,B.COLUMN_NAME
FROM ALL_CONSTRAINTS A , ALL_CONS_COLUMNS B WHERE A.CONSTRAINT_NAME=B.CONSTRAINT_NAME 
AND A.OWNER='ETL7' AND A.TABLE_NAME='CUSTOMER';

DELETE FROM city WHERE city_id = 30; --- WE CANNOT DELETE RECORD BECAUSE PARENT TABLE DEPEND ON CHILD TABLE ."integrity constraint (ETL7.SYS_C009165) violated - child record found" .

----HOW TO DROP FORIGN KEY CONSTRAINTS.
ALTER TABLE customer
DROP CONSTRAINT sys_c009165;

---ALREADY WE ARE DROPED "REFRENCE CONSTRAINTS" IN PREVIOUS STEP. BY CREATING "FORIGN KEY" RELATION WITH "ON DELET CASCADE OPTION", IF WE DELETE RECORD IN PARENT TABLE IT WILL ALSO DELETE RELATED RECORDS IN CHILD TABLE TOO. 
ALTER TABLE customer
ADD CONSTRAINT city_fk
FOREIGN KEY (city_id)
REFERENCES city(city_id)
ON DELETE CASCADE;

Delete From City Where City_Id=30;


----HOW TO DEFINE "COMPOSIT KEY"
CREATE TABLE customer1
(
cust_id NUMBER(6),
cust_name VARCHAR2(30) NOT NULL,
mobile_no NUMBER(10),
age NUMBER(3) CHECK (age>=18),
city_id NUMBER(4) REFERENCES city(city_id),
PRIMARY KEY(cust_id,mobile_no)
);

INSERT INTO customer1 VALUES (100000,'Arun',9090909090,28,20);

INSERT INTO customer1 VALUES (100000,'Arun',9090909091,28,20);

INSERT INTO customer1 VALUES (100000,'Arun',9090909091,28,20);---"unique constraint (ETL7.SYS_C009174) violated" BECAUSE CUST_ID 100000 AND  mobile_no 9090909091 COMBINATION ALREADY PRESENT IT SHOULD NOT BE REPEATED. 

INSERT INTO customer1 VALUES (100001,'Arun',9090909090,28,20);

SELECT * FROM customer1; 



----19. SELECT FIRST LETTER FROM FIRST NAME AND SECOND LETTER FROM LAST NAME OF THE FULLNAME.
---HERE WE DONT HAVE FULL NAME SO I CREATED FULL NAME AND THEN EXTRACTED FIRST LETTERS FROM FULL NAME.
SELECT SUBSTR(FULL_NAME,1,1) F_L,SUBSTR(FULL_NAME,INSTR(FULL_NAME,' ',1,1),2) S_L FROM 
                        ( SELECT FIRST_NAME || ' ' || LAST_NAME FULL_NAME FROM EMPLOYEES);
                        
                        
WITH DT AS (SELECT 'ANUSHA ESWRAPPA' D FROM DUAL)

SELECT SUBSTR(D,1,1) F_L,SUBSTR(D,INSTR(D,' ',1,1),2) S_L FROM DT;

-----IF FULL NAME HAS MORE NUMBER OF SPACE BETWEEN THEM THEN USE THIS. 

---STEPS:1
SELECT SUBSTR(FULL_NAME,1,1), SUBSTR(FULL_NAME,INSTR(FULL_NAME,' ',1,1)) FROM NAMES1;

---STEPS:2
SELECT SUBSTR(FULL_NAME,1,1), LTRIM(SUBSTR(FULL_NAME,INSTR(FULL_NAME,' ',1,1)),' ') FROM NAMES1;

---STEPS:3
SELECT SUBSTR(FULL_NAME,1,1), SUBSTR(LTRIM(SUBSTR(FULL_NAME,INSTR(FULL_NAME,' ',1,1)),' '),1,1) FROM NAMES1;


SELECT * FROM NAMES1;

INSERT INTO NAMES1 VALUES('SHARANA BASAPPA KALI M');
INSERT INTO NAMES1 VALUES('SHARANA BASAPPA KALI');

---HOW TO FIND FIRST LETTER FROM FIRST  NAME AND FIRST LETTER FROM LAST NAME(HERE WE HAVE MIDDLE NAME ALSO).
SELECT FULL_NAME,SUBSTR(FULL_NAME,1,1),SUBSTR(SUBSTR(FULL_NAME,INSTR(FULL_NAME,' ',-1,1)),1,2) FROM NAMES1;


----HOW TO IDENTIFY THE LETTER "A" WHICH IS PRESENT ONLY "2" TIMES IN THE NAME COLUMN.

SELECT * FROM (
            SELECT LOWER(FIRST_NAME),regexp_count(LOWER(FIRST_NAME),'a') AS A_COUNT FROM EMPLOYEES)
WHERE A_COUNT = 2;
-----OR

SELECT LOWER(FIRST_NAME)FROM EMPLOYEES
WHERE LENGTH(LOWER(FIRST_NAME)) - LENGTH(REPLACE(LOWER(FIRST_NAME),'a','')) = 2;
 

---20.HOW TO FIND FIRST DAY AND LAST DAY OF THE QUATER.

SELECT TRUNC(TO_DATE('22-MAY-21'),'Q') FROM DUAL;---IT WILL GIVES FIRST DAY OF THE QUATER.

SELECT TRUNC(TO_DATE('22-FEB-21'),'Q') FROM DUAL;---IT WILL GIVES FIRST DAY OF THE QUATER

SELECT LAST_DAY(TRUNC(TO_DATE('22-FEB-21'),'Q')+75) FROM DUAL;---IT WILL GIVES LAST DAY OF THE QUATER

SELECT LAST_DAY(TRUNC(TO_DATE('22-MAY-21'),'Q')+75) FROM DUAL;---IT WILL GIVES LAST DAY OF THE QUATER.


----21.How do you define Inner join(COMPARE THE RESULT AND IDENTIFY DIFFERENCE).
    --> Inner join creates new result table by combining column values of two tables(table1,table2).
    --> The query compares each row of table1 with each row of table2 to find all pairs of rows which satisfy. 
    --> HERE EXPECTED RESULT IN NOT JUST 1,2 ONLY, BECAUSE IT COMPARES EVERY ROW OF EACH TABLE GIVES OUTPUT(1,1,1,1,1,1,2).
    
CREATE TABLE INNERJOIN1
(ID NUMBER);

INSERT ALL 
INTO INNERJOIN1 VALUES(1)
INTO INNERJOIN1 VALUES(1)
INTO INNERJOIN1 VALUES(1)
INTO INNERJOIN1 VALUES(2)
SELECT * FROM DUAL;

CREATE TABLE INNERJOIN2
(ID NUMBER);

INSERT ALL 
INTO INNERJOIN2 VALUES(1)
INTO INNERJOIN2 VALUES(1)
INTO INNERJOIN2 VALUES(2)
INTO INNERJOIN2 VALUES(3)
SELECT * FROM DUAL;

---INNER JOIN
SELECT A.ID
FROM INNERJOIN1 A
INNER JOIN INNERJOIN2 B
ON A.ID=B.ID;

---LEFT OUTER JOIN.
SELECT A.ID
FROM INNERJOIN1 A
LEFT OUTER JOIN INNERJOIN2 B
ON A.ID=B.ID;


---RIGHT OUTER JOIN.
SELECT B.ID
FROM INNERJOIN1 A
RIGHT OUTER JOIN INNERJOIN2 B
ON A.ID=B.ID;



----22. HOW TO LOAD UNIQUE RECORD TO NEW TABLE FROM EXISTING TABLE.
CREATE TABLE INNERJOIN3 AS SELECT DISTINCT ID FROM INNERJOIN1;

SELECT * FROM INNERJOIN3;


---23 WRITE A SQL QUERY TO IDENTIFY THE FIRSTNAME THAT CONTAINS SECOND POSITION OF THE CHARACTER SHOULD BE AN VOWEL (a,e,i,o,u).
CREATE TABLE VOWEL
(FIRST_NAMES VARCHAR2(20));


INSERT ALL
INTO VOWEL VALUES('Mahesh')
INTO VOWEL VALUES('Santosh')
INTO VOWEL VALUES('Janak')
INTO VOWEL VALUES('Ramesh')
INTO VOWEL VALUES('suresh')
INTO VOWEL VALUES('chetu')
SELECT * FROM DUAL;


SELECT * FROM VOWEL
WHERE SUBSTR(FIRST_NAMES,2,1) IN ('a','e','i','o','u');

---OR
SELECT FIRST_NAMES FROM VOWEL
WHERE   FIRST_NAMES LIKE '_a%' OR
        FIRST_NAMES LIKE '_e%' OR
        FIRST_NAMES LIKE '_i%' OR
        FIRST_NAMES LIKE '_o%' OR
        FIRST_NAMES LIKE '_u%' ;


----24. HOW TO SHOW "SAMPLE" WORD AS SINGLE LETTER IN COLUMNS.
SELECT SUBSTR(RTRIM('SAMPLE99@GMAIL.COM','99@GMAIL.COM'),LEVEL,1) FROM DUAL
CONNECT BY LEVEL <=6;


----25.FINDING FIRST LETTER OF STRING AND LAST LETTER OF STRING WITH OUT USING "LIKE" OPERATOR.

SELECT * FROM EMPLOYEES
WHERE SUBSTR(FIRST_NAME,1,1)='M';

SELECT * FROM EMPLOYEES
WHERE SUBSTR(FIRST_NAME,-1,1)='s';

----26. FIRST AND LAST LETTER CONTAIN (A,E,I,O,U)  WITH OUT USING "LIKE" OPERATOR.

SELECT * FROM EMPLOYEES
WHERE SUBSTR(FIRST_NAME,1,1) IN ('A','E','I','O','U');---FIRST LETTER CONTAINING (A,E,I,O,U)

SELECT * FROM EMPLOYEES
WHERE SUBSTR(FIRST_NAME,-1,1) IN ('a','e','i','o','U');---FIRST LETTER FROM LAST CONTAINING (A,E,I,O,U)


SELECT * FROM EMPLOYEES
WHERE SUBSTR(FIRST_NAME,2,1) IN ('a','e','i','o','u');---SECOND LETTER CONTAINING (A,E,I,O,U)

SELECT * FROM EMPLOYEES
WHERE SUBSTR(FIRST_NAME,-2,1) IN ('a','e','i','o','U');---SECOND LETTER FROM LAST CONTAINING (A,E,I,O,U)





commit;
